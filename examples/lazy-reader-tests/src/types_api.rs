// Generated by Molecule 0.7.5

use molecule::prelude::*;
#[derive(Clone)]
pub struct Byte2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte2 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte2::new_unchecked(v)
    }
}
impl Byte2 {
    const DEFAULT_VALUE: [u8; 2] = [0, 0];
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte2 {
    type Builder = Byte2Builder;
    const NAME: &'static str = "Byte2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte2Reader<'r> {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte2Reader<'r> {
    type Entity = Byte2;
    const NAME: &'static str = "Byte2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte2Builder(pub(crate) [Byte; 2]);
impl ::core::fmt::Debug for Byte2Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte2Builder {
    fn default() -> Self {
        Byte2Builder([Byte::default(), Byte::default()])
    }
}
impl Byte2Builder {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Byte; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte2Builder {
    type Entity = Byte2;
    const NAME: &'static str = "Byte2Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte3::new_unchecked(v)
    }
}
impl Byte3 {
    const DEFAULT_VALUE: [u8; 3] = [0, 0, 0];
    pub const TOTAL_SIZE: usize = 3;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte3 {
    type Builder = Byte3Builder;
    const NAME: &'static str = "Byte3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte3Reader<'r> {
    pub const TOTAL_SIZE: usize = 3;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte3Reader<'r> {
    type Entity = Byte3;
    const NAME: &'static str = "Byte3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte3Builder(pub(crate) [Byte; 3]);
impl ::core::fmt::Debug for Byte3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte3Builder {
    fn default() -> Self {
        Byte3Builder([Byte::default(), Byte::default(), Byte::default()])
    }
}
impl Byte3Builder {
    pub const TOTAL_SIZE: usize = 3;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [Byte; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte3Builder {
    type Entity = Byte3;
    const NAME: &'static str = "Byte3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte4(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte4 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte4::new_unchecked(v)
    }
}
impl Byte4 {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte4Reader<'r> {
        Byte4Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte4 {
    type Builder = Byte4Builder;
    const NAME: &'static str = "Byte4";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte4(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte4Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte4Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte4Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte4Reader<'r> {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte4Reader<'r> {
    type Entity = Byte4;
    const NAME: &'static str = "Byte4Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte4Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte4Builder(pub(crate) [Byte; 4]);
impl ::core::fmt::Debug for Byte4Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte4Builder {
    fn default() -> Self {
        Byte4Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte4Builder {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn set(mut self, v: [Byte; 4]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte4Builder {
    type Entity = Byte4;
    const NAME: &'static str = "Byte4Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte4::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte5(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte5 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte5::new_unchecked(v)
    }
}
impl Byte5 {
    const DEFAULT_VALUE: [u8; 5] = [0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 5;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 5;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte5Reader<'r> {
        Byte5Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte5 {
    type Builder = Byte5Builder;
    const NAME: &'static str = "Byte5";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte5(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte5Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte5Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte5Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte5Reader<'r> {
    pub const TOTAL_SIZE: usize = 5;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 5;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte5Reader<'r> {
    type Entity = Byte5;
    const NAME: &'static str = "Byte5Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte5Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte5Builder(pub(crate) [Byte; 5]);
impl ::core::fmt::Debug for Byte5Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte5Builder {
    fn default() -> Self {
        Byte5Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte5Builder {
    pub const TOTAL_SIZE: usize = 5;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 5;
    pub fn set(mut self, v: [Byte; 5]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte5Builder {
    type Entity = Byte5;
    const NAME: &'static str = "Byte5Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte5::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte6(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte6 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte6::new_unchecked(v)
    }
}
impl Byte6 {
    const DEFAULT_VALUE: [u8; 6] = [0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 6;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 6;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte6Reader<'r> {
        Byte6Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte6 {
    type Builder = Byte6Builder;
    const NAME: &'static str = "Byte6";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte6(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte6Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte6Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte6Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte6Reader<'r> {
    pub const TOTAL_SIZE: usize = 6;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 6;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte6Reader<'r> {
    type Entity = Byte6;
    const NAME: &'static str = "Byte6Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte6Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte6Builder(pub(crate) [Byte; 6]);
impl ::core::fmt::Debug for Byte6Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte6Builder {
    fn default() -> Self {
        Byte6Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte6Builder {
    pub const TOTAL_SIZE: usize = 6;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 6;
    pub fn set(mut self, v: [Byte; 6]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte6Builder {
    type Entity = Byte6;
    const NAME: &'static str = "Byte6Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte6::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte7(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte7 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte7::new_unchecked(v)
    }
}
impl Byte7 {
    const DEFAULT_VALUE: [u8; 7] = [0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 7;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 7;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte7Reader<'r> {
        Byte7Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte7 {
    type Builder = Byte7Builder;
    const NAME: &'static str = "Byte7";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte7(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte7Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte7Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte7Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte7Reader<'r> {
    pub const TOTAL_SIZE: usize = 7;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 7;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte7Reader<'r> {
    type Entity = Byte7;
    const NAME: &'static str = "Byte7Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte7Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte7Builder(pub(crate) [Byte; 7]);
impl ::core::fmt::Debug for Byte7Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte7Builder {
    fn default() -> Self {
        Byte7Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte7Builder {
    pub const TOTAL_SIZE: usize = 7;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 7;
    pub fn set(mut self, v: [Byte; 7]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte7Builder {
    type Entity = Byte7;
    const NAME: &'static str = "Byte7Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte7::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte8(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte8 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte8::new_unchecked(v)
    }
}
impl Byte8 {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte8Reader<'r> {
        Byte8Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte8 {
    type Builder = Byte8Builder;
    const NAME: &'static str = "Byte8";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte8(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte8Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte8Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte8Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte8Reader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte8Reader<'r> {
    type Entity = Byte8;
    const NAME: &'static str = "Byte8Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte8Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte8Builder(pub(crate) [Byte; 8]);
impl ::core::fmt::Debug for Byte8Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte8Builder {
    fn default() -> Self {
        Byte8Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte8Builder {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn set(mut self, v: [Byte; 8]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte8Builder {
    type Entity = Byte8;
    const NAME: &'static str = "Byte8Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte8::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte9(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte9 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte9::new_unchecked(v)
    }
}
impl Byte9 {
    const DEFAULT_VALUE: [u8; 9] = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 9;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 9;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte9Reader<'r> {
        Byte9Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte9 {
    type Builder = Byte9Builder;
    const NAME: &'static str = "Byte9";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte9(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte9Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte9Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte9Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte9Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte9Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte9Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte9Reader<'r> {
    pub const TOTAL_SIZE: usize = 9;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 9;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte9Reader<'r> {
    type Entity = Byte9;
    const NAME: &'static str = "Byte9Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte9Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte9Builder(pub(crate) [Byte; 9]);
impl ::core::fmt::Debug for Byte9Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte9Builder {
    fn default() -> Self {
        Byte9Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte9Builder {
    pub const TOTAL_SIZE: usize = 9;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 9;
    pub fn set(mut self, v: [Byte; 9]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte9Builder {
    type Entity = Byte9;
    const NAME: &'static str = "Byte9Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte9::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte10(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte10 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte10::new_unchecked(v)
    }
}
impl Byte10 {
    const DEFAULT_VALUE: [u8; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 10;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 10;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte10Reader<'r> {
        Byte10Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte10 {
    type Builder = Byte10Builder;
    const NAME: &'static str = "Byte10";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte10(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte10Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte10Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte10Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte10Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte10Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte10Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte10Reader<'r> {
    pub const TOTAL_SIZE: usize = 10;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 10;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte10Reader<'r> {
    type Entity = Byte10;
    const NAME: &'static str = "Byte10Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte10Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte10Builder(pub(crate) [Byte; 10]);
impl ::core::fmt::Debug for Byte10Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte10Builder {
    fn default() -> Self {
        Byte10Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte10Builder {
    pub const TOTAL_SIZE: usize = 10;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 10;
    pub fn set(mut self, v: [Byte; 10]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte10Builder {
    type Entity = Byte10;
    const NAME: &'static str = "Byte10Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte10::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte11(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte11 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte11::new_unchecked(v)
    }
}
impl Byte11 {
    const DEFAULT_VALUE: [u8; 11] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 11;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 11;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte11Reader<'r> {
        Byte11Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte11 {
    type Builder = Byte11Builder;
    const NAME: &'static str = "Byte11";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte11(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte11Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte11Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte11Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte11Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte11Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte11Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte11Reader<'r> {
    pub const TOTAL_SIZE: usize = 11;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 11;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte11Reader<'r> {
    type Entity = Byte11;
    const NAME: &'static str = "Byte11Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte11Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte11Builder(pub(crate) [Byte; 11]);
impl ::core::fmt::Debug for Byte11Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte11Builder {
    fn default() -> Self {
        Byte11Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte11Builder {
    pub const TOTAL_SIZE: usize = 11;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 11;
    pub fn set(mut self, v: [Byte; 11]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte11Builder {
    type Entity = Byte11;
    const NAME: &'static str = "Byte11Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte11::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte12(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte12 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte12::new_unchecked(v)
    }
}
impl Byte12 {
    const DEFAULT_VALUE: [u8; 12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte12Reader<'r> {
        Byte12Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte12 {
    type Builder = Byte12Builder;
    const NAME: &'static str = "Byte12";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte12(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte12Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte12Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte12Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte12Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte12Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte12Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte12Reader<'r> {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte12Reader<'r> {
    type Entity = Byte12;
    const NAME: &'static str = "Byte12Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte12Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte12Builder(pub(crate) [Byte; 12]);
impl ::core::fmt::Debug for Byte12Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte12Builder {
    fn default() -> Self {
        Byte12Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte12Builder {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn set(mut self, v: [Byte; 12]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte12Builder {
    type Entity = Byte12;
    const NAME: &'static str = "Byte12Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte12::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte13(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte13 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte13::new_unchecked(v)
    }
}
impl Byte13 {
    const DEFAULT_VALUE: [u8; 13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 13;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 13;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte13Reader<'r> {
        Byte13Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte13 {
    type Builder = Byte13Builder;
    const NAME: &'static str = "Byte13";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte13(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte13Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte13Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte13Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte13Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte13Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte13Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte13Reader<'r> {
    pub const TOTAL_SIZE: usize = 13;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 13;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte13Reader<'r> {
    type Entity = Byte13;
    const NAME: &'static str = "Byte13Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte13Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte13Builder(pub(crate) [Byte; 13]);
impl ::core::fmt::Debug for Byte13Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte13Builder {
    fn default() -> Self {
        Byte13Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte13Builder {
    pub const TOTAL_SIZE: usize = 13;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 13;
    pub fn set(mut self, v: [Byte; 13]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte13Builder {
    type Entity = Byte13;
    const NAME: &'static str = "Byte13Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte13::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte14(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte14 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte14::new_unchecked(v)
    }
}
impl Byte14 {
    const DEFAULT_VALUE: [u8; 14] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 14;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 14;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte14Reader<'r> {
        Byte14Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte14 {
    type Builder = Byte14Builder;
    const NAME: &'static str = "Byte14";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte14(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte14Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte14Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte14Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte14Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte14Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte14Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte14Reader<'r> {
    pub const TOTAL_SIZE: usize = 14;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 14;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte14Reader<'r> {
    type Entity = Byte14;
    const NAME: &'static str = "Byte14Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte14Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte14Builder(pub(crate) [Byte; 14]);
impl ::core::fmt::Debug for Byte14Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte14Builder {
    fn default() -> Self {
        Byte14Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte14Builder {
    pub const TOTAL_SIZE: usize = 14;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 14;
    pub fn set(mut self, v: [Byte; 14]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte14Builder {
    type Entity = Byte14;
    const NAME: &'static str = "Byte14Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte14::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte15(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte15 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte15::new_unchecked(v)
    }
}
impl Byte15 {
    const DEFAULT_VALUE: [u8; 15] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 15;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 15;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte15Reader<'r> {
        Byte15Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte15 {
    type Builder = Byte15Builder;
    const NAME: &'static str = "Byte15";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte15(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte15Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte15Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte15Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte15Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte15Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte15Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte15Reader<'r> {
    pub const TOTAL_SIZE: usize = 15;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 15;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte15Reader<'r> {
    type Entity = Byte15;
    const NAME: &'static str = "Byte15Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte15Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte15Builder(pub(crate) [Byte; 15]);
impl ::core::fmt::Debug for Byte15Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte15Builder {
    fn default() -> Self {
        Byte15Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte15Builder {
    pub const TOTAL_SIZE: usize = 15;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 15;
    pub fn set(mut self, v: [Byte; 15]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte15Builder {
    type Entity = Byte15;
    const NAME: &'static str = "Byte15Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte15::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte16(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Byte16 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte16::new_unchecked(v)
    }
}
impl Byte16 {
    const DEFAULT_VALUE: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 16;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> Byte16Reader<'r> {
        Byte16Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte16 {
    type Builder = Byte16Builder;
    const NAME: &'static str = "Byte16";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte16(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte16Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte16Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Byte16Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte16Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> Byte16Reader<'r> {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 16;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte16Reader<'r> {
    type Entity = Byte16;
    const NAME: &'static str = "Byte16Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte16Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte16Builder(pub(crate) [Byte; 16]);
impl ::core::fmt::Debug for Byte16Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte16Builder {
    fn default() -> Self {
        Byte16Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl Byte16Builder {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 16;
    pub fn set(mut self, v: [Byte; 16]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte16Builder {
    type Entity = Byte16;
    const NAME: &'static str = "Byte16Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte16::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Word {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word::new_unchecked(v)
    }
}
impl Word {
    const DEFAULT_VALUE: [u8; 2] = [0, 0];
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> WordReader<'r> {
        WordReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word {
    type Builder = WordBuilder;
    const NAME: &'static str = "Word";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct WordReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> WordReader<'r> {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordReader<'r> {
    type Entity = Word;
    const NAME: &'static str = "WordReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct WordBuilder(pub(crate) [Byte; 2]);
impl ::core::fmt::Debug for WordBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for WordBuilder {
    fn default() -> Self {
        WordBuilder([Byte::default(), Byte::default()])
    }
}
impl WordBuilder {
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Byte; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for WordBuilder {
    type Entity = Word;
    const NAME: &'static str = "WordBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word2 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word2::new_unchecked(v)
    }
}
impl Word2 {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn as_reader<'r>(&'r self) -> Word2Reader<'r> {
        Word2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word2 {
    type Builder = Word2Builder;
    const NAME: &'static str = "Word2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct Word2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl<'r> Word2Reader<'r> {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word2Reader<'r> {
    type Entity = Word2;
    const NAME: &'static str = "Word2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word2Builder(pub(crate) [Word; 2]);
impl ::core::fmt::Debug for Word2Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word2Builder {
    fn default() -> Self {
        Word2Builder([Word::default(), Word::default()])
    }
}
impl Word2Builder {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Word; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for Word2Builder {
    type Entity = Word2;
    const NAME: &'static str = "Word2Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word3::new_unchecked(v)
    }
}
impl Word3 {
    const DEFAULT_VALUE: [u8; 6] = [0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 6;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn nth2(&self) -> Word {
        Word::new_unchecked(self.0.slice(4..6))
    }
    pub fn as_reader<'r>(&'r self) -> Word3Reader<'r> {
        Word3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word3 {
    type Builder = Word3Builder;
    const NAME: &'static str = "Word3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct Word3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl<'r> Word3Reader<'r> {
    pub const TOTAL_SIZE: usize = 6;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn nth2(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[4..6])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word3Reader<'r> {
    type Entity = Word3;
    const NAME: &'static str = "Word3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word3Builder(pub(crate) [Word; 3]);
impl ::core::fmt::Debug for Word3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word3Builder {
    fn default() -> Self {
        Word3Builder([Word::default(), Word::default(), Word::default()])
    }
}
impl Word3Builder {
    pub const TOTAL_SIZE: usize = 6;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [Word; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Word) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for Word3Builder {
    type Entity = Word3;
    const NAME: &'static str = "Word3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word4(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word4 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word4::new_unchecked(v)
    }
}
impl Word4 {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn nth2(&self) -> Word {
        Word::new_unchecked(self.0.slice(4..6))
    }
    pub fn nth3(&self) -> Word {
        Word::new_unchecked(self.0.slice(6..8))
    }
    pub fn as_reader<'r>(&'r self) -> Word4Reader<'r> {
        Word4Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word4 {
    type Builder = Word4Builder;
    const NAME: &'static str = "Word4";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word4(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word4Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word4Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
#[derive(Clone, Copy)]
pub struct Word4Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, "]")
    }
}
impl<'r> Word4Reader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn nth2(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn nth3(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[6..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word4Reader<'r> {
    type Entity = Word4;
    const NAME: &'static str = "Word4Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word4Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word4Builder(pub(crate) [Word; 4]);
impl ::core::fmt::Debug for Word4Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word4Builder {
    fn default() -> Self {
        Word4Builder([
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
        ])
    }
}
impl Word4Builder {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 4;
    pub fn set(mut self, v: [Word; 4]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Word) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Word) -> Self {
        self.0[3] = v;
        self
    }
}
impl molecule::prelude::Builder for Word4Builder {
    type Entity = Word4;
    const NAME: &'static str = "Word4Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word4::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word5(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word5 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word5::new_unchecked(v)
    }
}
impl Word5 {
    const DEFAULT_VALUE: [u8; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 10;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 5;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn nth2(&self) -> Word {
        Word::new_unchecked(self.0.slice(4..6))
    }
    pub fn nth3(&self) -> Word {
        Word::new_unchecked(self.0.slice(6..8))
    }
    pub fn nth4(&self) -> Word {
        Word::new_unchecked(self.0.slice(8..10))
    }
    pub fn as_reader<'r>(&'r self) -> Word5Reader<'r> {
        Word5Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word5 {
    type Builder = Word5Builder;
    const NAME: &'static str = "Word5";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word5(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word5Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word5Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Word5Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, "]")
    }
}
impl<'r> Word5Reader<'r> {
    pub const TOTAL_SIZE: usize = 10;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 5;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn nth2(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn nth3(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[6..8])
    }
    pub fn nth4(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[8..10])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word5Reader<'r> {
    type Entity = Word5;
    const NAME: &'static str = "Word5Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word5Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word5Builder(pub(crate) [Word; 5]);
impl ::core::fmt::Debug for Word5Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word5Builder {
    fn default() -> Self {
        Word5Builder([
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
        ])
    }
}
impl Word5Builder {
    pub const TOTAL_SIZE: usize = 10;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 5;
    pub fn set(mut self, v: [Word; 5]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Word) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Word) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Word) -> Self {
        self.0[4] = v;
        self
    }
}
impl molecule::prelude::Builder for Word5Builder {
    type Entity = Word5;
    const NAME: &'static str = "Word5Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word5::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word6(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word6 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word6::new_unchecked(v)
    }
}
impl Word6 {
    const DEFAULT_VALUE: [u8; 12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 6;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn nth2(&self) -> Word {
        Word::new_unchecked(self.0.slice(4..6))
    }
    pub fn nth3(&self) -> Word {
        Word::new_unchecked(self.0.slice(6..8))
    }
    pub fn nth4(&self) -> Word {
        Word::new_unchecked(self.0.slice(8..10))
    }
    pub fn nth5(&self) -> Word {
        Word::new_unchecked(self.0.slice(10..12))
    }
    pub fn as_reader<'r>(&'r self) -> Word6Reader<'r> {
        Word6Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word6 {
    type Builder = Word6Builder;
    const NAME: &'static str = "Word6";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word6(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word6Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word6Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Word6Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, "]")
    }
}
impl<'r> Word6Reader<'r> {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 6;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn nth2(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn nth3(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[6..8])
    }
    pub fn nth4(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[8..10])
    }
    pub fn nth5(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[10..12])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word6Reader<'r> {
    type Entity = Word6;
    const NAME: &'static str = "Word6Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word6Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word6Builder(pub(crate) [Word; 6]);
impl ::core::fmt::Debug for Word6Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word6Builder {
    fn default() -> Self {
        Word6Builder([
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
        ])
    }
}
impl Word6Builder {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 6;
    pub fn set(mut self, v: [Word; 6]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Word) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Word) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Word) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Word) -> Self {
        self.0[5] = v;
        self
    }
}
impl molecule::prelude::Builder for Word6Builder {
    type Entity = Word6;
    const NAME: &'static str = "Word6Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word6::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word7(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, ", {}", self.nth6())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word7 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word7::new_unchecked(v)
    }
}
impl Word7 {
    const DEFAULT_VALUE: [u8; 14] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 14;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 7;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn nth2(&self) -> Word {
        Word::new_unchecked(self.0.slice(4..6))
    }
    pub fn nth3(&self) -> Word {
        Word::new_unchecked(self.0.slice(6..8))
    }
    pub fn nth4(&self) -> Word {
        Word::new_unchecked(self.0.slice(8..10))
    }
    pub fn nth5(&self) -> Word {
        Word::new_unchecked(self.0.slice(10..12))
    }
    pub fn nth6(&self) -> Word {
        Word::new_unchecked(self.0.slice(12..14))
    }
    pub fn as_reader<'r>(&'r self) -> Word7Reader<'r> {
        Word7Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word7 {
    type Builder = Word7Builder;
    const NAME: &'static str = "Word7";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word7(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word7Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word7Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Word7Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word7Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, ", {}", self.nth6())?;
        write!(f, "]")
    }
}
impl<'r> Word7Reader<'r> {
    pub const TOTAL_SIZE: usize = 14;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 7;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn nth2(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn nth3(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[6..8])
    }
    pub fn nth4(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[8..10])
    }
    pub fn nth5(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[10..12])
    }
    pub fn nth6(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[12..14])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word7Reader<'r> {
    type Entity = Word7;
    const NAME: &'static str = "Word7Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word7Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word7Builder(pub(crate) [Word; 7]);
impl ::core::fmt::Debug for Word7Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word7Builder {
    fn default() -> Self {
        Word7Builder([
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
        ])
    }
}
impl Word7Builder {
    pub const TOTAL_SIZE: usize = 14;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 7;
    pub fn set(mut self, v: [Word; 7]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Word) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Word) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Word) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Word) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Word) -> Self {
        self.0[6] = v;
        self
    }
}
impl molecule::prelude::Builder for Word7Builder {
    type Entity = Word7;
    const NAME: &'static str = "Word7Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word7::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Word8(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Word8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Word8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Word8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, ", {}", self.nth6())?;
        write!(f, ", {}", self.nth7())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Word8 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Word8::new_unchecked(v)
    }
}
impl Word8 {
    const DEFAULT_VALUE: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> Word {
        Word::new_unchecked(self.0.slice(0..2))
    }
    pub fn nth1(&self) -> Word {
        Word::new_unchecked(self.0.slice(2..4))
    }
    pub fn nth2(&self) -> Word {
        Word::new_unchecked(self.0.slice(4..6))
    }
    pub fn nth3(&self) -> Word {
        Word::new_unchecked(self.0.slice(6..8))
    }
    pub fn nth4(&self) -> Word {
        Word::new_unchecked(self.0.slice(8..10))
    }
    pub fn nth5(&self) -> Word {
        Word::new_unchecked(self.0.slice(10..12))
    }
    pub fn nth6(&self) -> Word {
        Word::new_unchecked(self.0.slice(12..14))
    }
    pub fn nth7(&self) -> Word {
        Word::new_unchecked(self.0.slice(14..16))
    }
    pub fn as_reader<'r>(&'r self) -> Word8Reader<'r> {
        Word8Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Word8 {
    type Builder = Word8Builder;
    const NAME: &'static str = "Word8";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Word8(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word8Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Word8Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct Word8Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Word8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Word8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Word8Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, ", {}", self.nth3())?;
        write!(f, ", {}", self.nth4())?;
        write!(f, ", {}", self.nth5())?;
        write!(f, ", {}", self.nth6())?;
        write!(f, ", {}", self.nth7())?;
        write!(f, "]")
    }
}
impl<'r> Word8Reader<'r> {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[0..2])
    }
    pub fn nth1(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn nth2(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn nth3(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[6..8])
    }
    pub fn nth4(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[8..10])
    }
    pub fn nth5(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[10..12])
    }
    pub fn nth6(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[12..14])
    }
    pub fn nth7(&self) -> WordReader<'r> {
        WordReader::new_unchecked(&self.as_slice()[14..16])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Word8Reader<'r> {
    type Entity = Word8;
    const NAME: &'static str = "Word8Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Word8Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Word8Builder(pub(crate) [Word; 8]);
impl ::core::fmt::Debug for Word8Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Word8Builder {
    fn default() -> Self {
        Word8Builder([
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
            Word::default(),
        ])
    }
}
impl Word8Builder {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 2;
    pub const ITEM_COUNT: usize = 8;
    pub fn set(mut self, v: [Word; 8]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Word) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Word) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Word) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Word) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Word) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Word) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Word) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Word) -> Self {
        self.0[7] = v;
        self
    }
}
impl molecule::prelude::Builder for Word8Builder {
    type Entity = Word8;
    const NAME: &'static str = "Word8Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Word8::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte3x3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte3x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte3x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte3x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Byte3x3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte3x3::new_unchecked(v)
    }
}
impl Byte3x3 {
    const DEFAULT_VALUE: [u8; 9] = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 9;
    pub const ITEM_SIZE: usize = 3;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(0..3))
    }
    pub fn nth1(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(3..6))
    }
    pub fn nth2(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(6..9))
    }
    pub fn as_reader<'r>(&'r self) -> Byte3x3Reader<'r> {
        Byte3x3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte3x3 {
    type Builder = Byte3x3Builder;
    const NAME: &'static str = "Byte3x3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte3x3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte3x3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte3x3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte3x3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte3x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte3x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte3x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl<'r> Byte3x3Reader<'r> {
    pub const TOTAL_SIZE: usize = 9;
    pub const ITEM_SIZE: usize = 3;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[0..3])
    }
    pub fn nth1(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[3..6])
    }
    pub fn nth2(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[6..9])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte3x3Reader<'r> {
    type Entity = Byte3x3;
    const NAME: &'static str = "Byte3x3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte3x3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte3x3Builder(pub(crate) [Byte3; 3]);
impl ::core::fmt::Debug for Byte3x3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte3x3Builder {
    fn default() -> Self {
        Byte3x3Builder([Byte3::default(), Byte3::default(), Byte3::default()])
    }
}
impl Byte3x3Builder {
    pub const TOTAL_SIZE: usize = 9;
    pub const ITEM_SIZE: usize = 3;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [Byte3; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte3) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte3) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte3) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte3x3Builder {
    type Entity = Byte3x3;
    const NAME: &'static str = "Byte3x3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte3x3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte5x3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte5x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte5x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte5x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Byte5x3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte5x3::new_unchecked(v)
    }
}
impl Byte5x3 {
    const DEFAULT_VALUE: [u8; 15] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 15;
    pub const ITEM_SIZE: usize = 5;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte5 {
        Byte5::new_unchecked(self.0.slice(0..5))
    }
    pub fn nth1(&self) -> Byte5 {
        Byte5::new_unchecked(self.0.slice(5..10))
    }
    pub fn nth2(&self) -> Byte5 {
        Byte5::new_unchecked(self.0.slice(10..15))
    }
    pub fn as_reader<'r>(&'r self) -> Byte5x3Reader<'r> {
        Byte5x3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte5x3 {
    type Builder = Byte5x3Builder;
    const NAME: &'static str = "Byte5x3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte5x3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte5x3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte5x3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte5x3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte5x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte5x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte5x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl<'r> Byte5x3Reader<'r> {
    pub const TOTAL_SIZE: usize = 15;
    pub const ITEM_SIZE: usize = 5;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte5Reader<'r> {
        Byte5Reader::new_unchecked(&self.as_slice()[0..5])
    }
    pub fn nth1(&self) -> Byte5Reader<'r> {
        Byte5Reader::new_unchecked(&self.as_slice()[5..10])
    }
    pub fn nth2(&self) -> Byte5Reader<'r> {
        Byte5Reader::new_unchecked(&self.as_slice()[10..15])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte5x3Reader<'r> {
    type Entity = Byte5x3;
    const NAME: &'static str = "Byte5x3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte5x3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte5x3Builder(pub(crate) [Byte5; 3]);
impl ::core::fmt::Debug for Byte5x3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte5x3Builder {
    fn default() -> Self {
        Byte5x3Builder([Byte5::default(), Byte5::default(), Byte5::default()])
    }
}
impl Byte5x3Builder {
    pub const TOTAL_SIZE: usize = 15;
    pub const ITEM_SIZE: usize = 5;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [Byte5; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte5) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte5) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte5) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte5x3Builder {
    type Entity = Byte5x3;
    const NAME: &'static str = "Byte5x3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte5x3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte7x3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte7x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte7x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte7x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Byte7x3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte7x3::new_unchecked(v)
    }
}
impl Byte7x3 {
    const DEFAULT_VALUE: [u8; 21] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 21;
    pub const ITEM_SIZE: usize = 7;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte7 {
        Byte7::new_unchecked(self.0.slice(0..7))
    }
    pub fn nth1(&self) -> Byte7 {
        Byte7::new_unchecked(self.0.slice(7..14))
    }
    pub fn nth2(&self) -> Byte7 {
        Byte7::new_unchecked(self.0.slice(14..21))
    }
    pub fn as_reader<'r>(&'r self) -> Byte7x3Reader<'r> {
        Byte7x3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte7x3 {
    type Builder = Byte7x3Builder;
    const NAME: &'static str = "Byte7x3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte7x3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte7x3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte7x3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte7x3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte7x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte7x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte7x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl<'r> Byte7x3Reader<'r> {
    pub const TOTAL_SIZE: usize = 21;
    pub const ITEM_SIZE: usize = 7;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte7Reader<'r> {
        Byte7Reader::new_unchecked(&self.as_slice()[0..7])
    }
    pub fn nth1(&self) -> Byte7Reader<'r> {
        Byte7Reader::new_unchecked(&self.as_slice()[7..14])
    }
    pub fn nth2(&self) -> Byte7Reader<'r> {
        Byte7Reader::new_unchecked(&self.as_slice()[14..21])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte7x3Reader<'r> {
    type Entity = Byte7x3;
    const NAME: &'static str = "Byte7x3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte7x3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte7x3Builder(pub(crate) [Byte7; 3]);
impl ::core::fmt::Debug for Byte7x3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte7x3Builder {
    fn default() -> Self {
        Byte7x3Builder([Byte7::default(), Byte7::default(), Byte7::default()])
    }
}
impl Byte7x3Builder {
    pub const TOTAL_SIZE: usize = 21;
    pub const ITEM_SIZE: usize = 7;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [Byte7; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte7) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte7) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte7) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte7x3Builder {
    type Entity = Byte7x3;
    const NAME: &'static str = "Byte7x3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte7x3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte9x3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte9x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte9x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte9x3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Byte9x3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte9x3::new_unchecked(v)
    }
}
impl Byte9x3 {
    const DEFAULT_VALUE: [u8; 27] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 27;
    pub const ITEM_SIZE: usize = 9;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte9 {
        Byte9::new_unchecked(self.0.slice(0..9))
    }
    pub fn nth1(&self) -> Byte9 {
        Byte9::new_unchecked(self.0.slice(9..18))
    }
    pub fn nth2(&self) -> Byte9 {
        Byte9::new_unchecked(self.0.slice(18..27))
    }
    pub fn as_reader<'r>(&'r self) -> Byte9x3Reader<'r> {
        Byte9x3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte9x3 {
    type Builder = Byte9x3Builder;
    const NAME: &'static str = "Byte9x3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte9x3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte9x3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte9x3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct Byte9x3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte9x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte9x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte9x3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl<'r> Byte9x3Reader<'r> {
    pub const TOTAL_SIZE: usize = 27;
    pub const ITEM_SIZE: usize = 9;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> Byte9Reader<'r> {
        Byte9Reader::new_unchecked(&self.as_slice()[0..9])
    }
    pub fn nth1(&self) -> Byte9Reader<'r> {
        Byte9Reader::new_unchecked(&self.as_slice()[9..18])
    }
    pub fn nth2(&self) -> Byte9Reader<'r> {
        Byte9Reader::new_unchecked(&self.as_slice()[18..27])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte9x3Reader<'r> {
    type Entity = Byte9x3;
    const NAME: &'static str = "Byte9x3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte9x3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct Byte9x3Builder(pub(crate) [Byte9; 3]);
impl ::core::fmt::Debug for Byte9x3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for Byte9x3Builder {
    fn default() -> Self {
        Byte9x3Builder([Byte9::default(), Byte9::default(), Byte9::default()])
    }
}
impl Byte9x3Builder {
    pub const TOTAL_SIZE: usize = 27;
    pub const ITEM_SIZE: usize = 9;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [Byte9; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte9) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte9) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte9) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for Byte9x3Builder {
    type Entity = Byte9x3;
    const NAME: &'static str = "Byte9x3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte9x3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructA(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructA {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructA::new_unchecked(v)
    }
}
impl StructA {
    const DEFAULT_VALUE: [u8; 6] = [0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 6;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 2];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn f3(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(2..4))
    }
    pub fn f4(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(4..6))
    }
    pub fn as_reader<'r>(&'r self) -> StructAReader<'r> {
        StructAReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructA {
    type Builder = StructABuilder;
    const NAME: &'static str = "StructA";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructA(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructAReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructAReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructAReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructAReader<'r> {
    pub const TOTAL_SIZE: usize = 6;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 2];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn f3(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn f4(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[4..6])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructAReader<'r> {
    type Entity = StructA;
    const NAME: &'static str = "StructAReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructAReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructABuilder {
    pub(crate) f1: Byte,
    pub(crate) f2: Byte,
    pub(crate) f3: Byte2,
    pub(crate) f4: Byte2,
}
impl StructABuilder {
    pub const TOTAL_SIZE: usize = 6;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 2];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte2) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte2) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructABuilder {
    type Entity = StructA;
    const NAME: &'static str = "StructABuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructA::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructB(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructB {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructB::new_unchecked(v)
    }
}
impl StructB {
    const DEFAULT_VALUE: [u8; 7] = [0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 7;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 3];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn f3(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(2..4))
    }
    pub fn f4(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(4..7))
    }
    pub fn as_reader<'r>(&'r self) -> StructBReader<'r> {
        StructBReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructB {
    type Builder = StructBBuilder;
    const NAME: &'static str = "StructB";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructB(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructBReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructBReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructBReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructBReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructBReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructBReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructBReader<'r> {
    pub const TOTAL_SIZE: usize = 7;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 3];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn f3(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn f4(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[4..7])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructBReader<'r> {
    type Entity = StructB;
    const NAME: &'static str = "StructBReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructBReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructBBuilder {
    pub(crate) f1: Byte,
    pub(crate) f2: Byte,
    pub(crate) f3: Byte2,
    pub(crate) f4: Byte3,
}
impl StructBBuilder {
    pub const TOTAL_SIZE: usize = 7;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 3];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte2) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte3) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructBBuilder {
    type Entity = StructB;
    const NAME: &'static str = "StructBBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructB::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructC(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructC {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructC::new_unchecked(v)
    }
}
impl StructC {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn f3(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(2..4))
    }
    pub fn f4(&self) -> Byte4 {
        Byte4::new_unchecked(self.0.slice(4..8))
    }
    pub fn as_reader<'r>(&'r self) -> StructCReader<'r> {
        StructCReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructC {
    type Builder = StructCBuilder;
    const NAME: &'static str = "StructC";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructC(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructCReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructCReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructCReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructCReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructCReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructCReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructCReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn f3(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn f4(&self) -> Byte4Reader<'r> {
        Byte4Reader::new_unchecked(&self.as_slice()[4..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructCReader<'r> {
    type Entity = StructC;
    const NAME: &'static str = "StructCReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructCReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructCBuilder {
    pub(crate) f1: Byte,
    pub(crate) f2: Byte,
    pub(crate) f3: Byte2,
    pub(crate) f4: Byte4,
}
impl StructCBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte2) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte4) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructCBuilder {
    type Entity = StructC;
    const NAME: &'static str = "StructCBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructC::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructD(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructD {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructD::new_unchecked(v)
    }
}
impl StructD {
    const DEFAULT_VALUE: [u8; 9] = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 9;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 5];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn f3(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(2..4))
    }
    pub fn f4(&self) -> Byte5 {
        Byte5::new_unchecked(self.0.slice(4..9))
    }
    pub fn as_reader<'r>(&'r self) -> StructDReader<'r> {
        StructDReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructD {
    type Builder = StructDBuilder;
    const NAME: &'static str = "StructD";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructD(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructDReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructDReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructDReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructDReader<'r> {
    pub const TOTAL_SIZE: usize = 9;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 5];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn f3(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[2..4])
    }
    pub fn f4(&self) -> Byte5Reader<'r> {
        Byte5Reader::new_unchecked(&self.as_slice()[4..9])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructDReader<'r> {
    type Entity = StructD;
    const NAME: &'static str = "StructDReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructDReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructDBuilder {
    pub(crate) f1: Byte,
    pub(crate) f2: Byte,
    pub(crate) f3: Byte2,
    pub(crate) f4: Byte5,
}
impl StructDBuilder {
    pub const TOTAL_SIZE: usize = 9;
    pub const FIELD_SIZES: [usize; 4] = [1, 1, 2, 5];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte2) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte5) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructDBuilder {
    type Entity = StructD;
    const NAME: &'static str = "StructDBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructD::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructE(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructE {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructE::new_unchecked(v)
    }
}
impl StructE {
    const DEFAULT_VALUE: [u8; 6] = [0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 6;
    pub const FIELD_SIZES: [usize; 4] = [1, 2, 1, 2];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn f2(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(1..3))
    }
    pub fn f3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn f4(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(4..6))
    }
    pub fn as_reader<'r>(&'r self) -> StructEReader<'r> {
        StructEReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructE {
    type Builder = StructEBuilder;
    const NAME: &'static str = "StructE";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructE(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructEReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructEReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructEReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructEReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructEReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructEReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructEReader<'r> {
    pub const TOTAL_SIZE: usize = 6;
    pub const FIELD_SIZES: [usize; 4] = [1, 2, 1, 2];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn f2(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[1..3])
    }
    pub fn f3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn f4(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[4..6])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructEReader<'r> {
    type Entity = StructE;
    const NAME: &'static str = "StructEReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructEReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructEBuilder {
    pub(crate) f1: Byte,
    pub(crate) f2: Byte2,
    pub(crate) f3: Byte,
    pub(crate) f4: Byte2,
}
impl StructEBuilder {
    pub const TOTAL_SIZE: usize = 6;
    pub const FIELD_SIZES: [usize; 4] = [1, 2, 1, 2];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte2) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte2) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructEBuilder {
    type Entity = StructE;
    const NAME: &'static str = "StructEBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructE::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructF(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructF {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructF::new_unchecked(v)
    }
}
impl StructF {
    const DEFAULT_VALUE: [u8; 5] = [0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 5;
    pub const FIELD_SIZES: [usize; 3] = [1, 3, 1];
    pub const FIELD_COUNT: usize = 3;
    pub fn f1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn f2(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(1..4))
    }
    pub fn f3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn as_reader<'r>(&'r self) -> StructFReader<'r> {
        StructFReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructF {
    type Builder = StructFBuilder;
    const NAME: &'static str = "StructF";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructF(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructFReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructFReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
    }
}
#[derive(Clone, Copy)]
pub struct StructFReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructFReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, " }}")
    }
}
impl<'r> StructFReader<'r> {
    pub const TOTAL_SIZE: usize = 5;
    pub const FIELD_SIZES: [usize; 3] = [1, 3, 1];
    pub const FIELD_COUNT: usize = 3;
    pub fn f1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn f2(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[1..4])
    }
    pub fn f3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructFReader<'r> {
    type Entity = StructF;
    const NAME: &'static str = "StructFReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructFReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructFBuilder {
    pub(crate) f1: Byte,
    pub(crate) f2: Byte3,
    pub(crate) f3: Byte,
}
impl StructFBuilder {
    pub const TOTAL_SIZE: usize = 5;
    pub const FIELD_SIZES: [usize; 3] = [1, 3, 1];
    pub const FIELD_COUNT: usize = 3;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte3) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte) -> Self {
        self.f3 = v;
        self
    }
}
impl molecule::prelude::Builder for StructFBuilder {
    type Entity = StructF;
    const NAME: &'static str = "StructFBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructF::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructG(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructG {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructG::new_unchecked(v)
    }
}
impl StructG {
    const DEFAULT_VALUE: [u8; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 10;
    pub const FIELD_SIZES: [usize; 4] = [3, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(0..3))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn f3(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(4..6))
    }
    pub fn f4(&self) -> Word2 {
        Word2::new_unchecked(self.0.slice(6..10))
    }
    pub fn as_reader<'r>(&'r self) -> StructGReader<'r> {
        StructGReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructG {
    type Builder = StructGBuilder;
    const NAME: &'static str = "StructG";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructG(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructGReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructGReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructGReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructGReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructGReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructGReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructGReader<'r> {
    pub const TOTAL_SIZE: usize = 10;
    pub const FIELD_SIZES: [usize; 4] = [3, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[0..3])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn f3(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn f4(&self) -> Word2Reader<'r> {
        Word2Reader::new_unchecked(&self.as_slice()[6..10])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructGReader<'r> {
    type Entity = StructG;
    const NAME: &'static str = "StructGReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructGReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructGBuilder {
    pub(crate) f1: Byte3,
    pub(crate) f2: Byte,
    pub(crate) f3: Byte2,
    pub(crate) f4: Word2,
}
impl StructGBuilder {
    pub const TOTAL_SIZE: usize = 10;
    pub const FIELD_SIZES: [usize; 4] = [3, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte3) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte2) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Word2) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructGBuilder {
    type Entity = StructG;
    const NAME: &'static str = "StructGBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructG::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructH(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructH {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructH::new_unchecked(v)
    }
}
impl StructH {
    const DEFAULT_VALUE: [u8; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 10;
    pub const FIELD_SIZES: [usize; 4] = [3, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(0..3))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn f3(&self) -> Byte2 {
        Byte2::new_unchecked(self.0.slice(4..6))
    }
    pub fn f4(&self) -> Byte4 {
        Byte4::new_unchecked(self.0.slice(6..10))
    }
    pub fn as_reader<'r>(&'r self) -> StructHReader<'r> {
        StructHReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructH {
    type Builder = StructHBuilder;
    const NAME: &'static str = "StructH";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructH(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructHReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructHReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct StructHReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructHReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructHReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructHReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, " }}")
    }
}
impl<'r> StructHReader<'r> {
    pub const TOTAL_SIZE: usize = 10;
    pub const FIELD_SIZES: [usize; 4] = [3, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[0..3])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn f3(&self) -> Byte2Reader<'r> {
        Byte2Reader::new_unchecked(&self.as_slice()[4..6])
    }
    pub fn f4(&self) -> Byte4Reader<'r> {
        Byte4Reader::new_unchecked(&self.as_slice()[6..10])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructHReader<'r> {
    type Entity = StructH;
    const NAME: &'static str = "StructHReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructHReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructHBuilder {
    pub(crate) f1: Byte3,
    pub(crate) f2: Byte,
    pub(crate) f3: Byte2,
    pub(crate) f4: Byte4,
}
impl StructHBuilder {
    pub const TOTAL_SIZE: usize = 10;
    pub const FIELD_SIZES: [usize; 4] = [3, 1, 2, 4];
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte3) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte2) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte4) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for StructHBuilder {
    type Entity = StructH;
    const NAME: &'static str = "StructHBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructH::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructI(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructI {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructI::new_unchecked(v)
    }
}
impl StructI {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 4;
    pub const FIELD_SIZES: [usize; 2] = [3, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> Byte3 {
        Byte3::new_unchecked(self.0.slice(0..3))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn as_reader<'r>(&'r self) -> StructIReader<'r> {
        StructIReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructI {
    type Builder = StructIBuilder;
    const NAME: &'static str = "StructI";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructI(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructIReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructIReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().f1(self.f1()).f2(self.f2())
    }
}
#[derive(Clone, Copy)]
pub struct StructIReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructIReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructIReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructIReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl<'r> StructIReader<'r> {
    pub const TOTAL_SIZE: usize = 4;
    pub const FIELD_SIZES: [usize; 2] = [3, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> Byte3Reader<'r> {
        Byte3Reader::new_unchecked(&self.as_slice()[0..3])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructIReader<'r> {
    type Entity = StructI;
    const NAME: &'static str = "StructIReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructIReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructIBuilder {
    pub(crate) f1: Byte3,
    pub(crate) f2: Byte,
}
impl StructIBuilder {
    pub const TOTAL_SIZE: usize = 4;
    pub const FIELD_SIZES: [usize; 2] = [3, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(mut self, v: Byte3) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
}
impl molecule::prelude::Builder for StructIBuilder {
    type Entity = StructI;
    const NAME: &'static str = "StructIBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructI::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructJ(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructJ {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructJ {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructJ {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructJ {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructJ::new_unchecked(v)
    }
}
impl StructJ {
    const DEFAULT_VALUE: [u8; 7] = [0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 7;
    pub const FIELD_SIZES: [usize; 2] = [6, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> Byte6 {
        Byte6::new_unchecked(self.0.slice(0..6))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn as_reader<'r>(&'r self) -> StructJReader<'r> {
        StructJReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructJ {
    type Builder = StructJBuilder;
    const NAME: &'static str = "StructJ";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructJ(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructJReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructJReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().f1(self.f1()).f2(self.f2())
    }
}
#[derive(Clone, Copy)]
pub struct StructJReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructJReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructJReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructJReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl<'r> StructJReader<'r> {
    pub const TOTAL_SIZE: usize = 7;
    pub const FIELD_SIZES: [usize; 2] = [6, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> Byte6Reader<'r> {
        Byte6Reader::new_unchecked(&self.as_slice()[0..6])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructJReader<'r> {
    type Entity = StructJ;
    const NAME: &'static str = "StructJReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructJReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructJBuilder {
    pub(crate) f1: Byte6,
    pub(crate) f2: Byte,
}
impl StructJBuilder {
    pub const TOTAL_SIZE: usize = 7;
    pub const FIELD_SIZES: [usize; 2] = [6, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(mut self, v: Byte6) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
}
impl molecule::prelude::Builder for StructJBuilder {
    type Entity = StructJ;
    const NAME: &'static str = "StructJBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructJ::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructIx3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructIx3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructIx3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructIx3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for StructIx3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructIx3::new_unchecked(v)
    }
}
impl StructIx3 {
    const DEFAULT_VALUE: [u8; 12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 4;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> StructI {
        StructI::new_unchecked(self.0.slice(0..4))
    }
    pub fn nth1(&self) -> StructI {
        StructI::new_unchecked(self.0.slice(4..8))
    }
    pub fn nth2(&self) -> StructI {
        StructI::new_unchecked(self.0.slice(8..12))
    }
    pub fn as_reader<'r>(&'r self) -> StructIx3Reader<'r> {
        StructIx3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructIx3 {
    type Builder = StructIx3Builder;
    const NAME: &'static str = "StructIx3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructIx3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructIx3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructIx3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2()])
    }
}
#[derive(Clone, Copy)]
pub struct StructIx3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructIx3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructIx3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructIx3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, ", {}", self.nth2())?;
        write!(f, "]")
    }
}
impl<'r> StructIx3Reader<'r> {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 4;
    pub const ITEM_COUNT: usize = 3;
    pub fn nth0(&self) -> StructIReader<'r> {
        StructIReader::new_unchecked(&self.as_slice()[0..4])
    }
    pub fn nth1(&self) -> StructIReader<'r> {
        StructIReader::new_unchecked(&self.as_slice()[4..8])
    }
    pub fn nth2(&self) -> StructIReader<'r> {
        StructIReader::new_unchecked(&self.as_slice()[8..12])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructIx3Reader<'r> {
    type Entity = StructIx3;
    const NAME: &'static str = "StructIx3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructIx3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct StructIx3Builder(pub(crate) [StructI; 3]);
impl ::core::fmt::Debug for StructIx3Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for StructIx3Builder {
    fn default() -> Self {
        StructIx3Builder([StructI::default(), StructI::default(), StructI::default()])
    }
}
impl StructIx3Builder {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 4;
    pub const ITEM_COUNT: usize = 3;
    pub fn set(mut self, v: [StructI; 3]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: StructI) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: StructI) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: StructI) -> Self {
        self.0[2] = v;
        self
    }
}
impl molecule::prelude::Builder for StructIx3Builder {
    type Entity = StructIx3;
    const NAME: &'static str = "StructIx3Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructIx3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructO(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructO {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructO::new_unchecked(v)
    }
}
impl StructO {
    const DEFAULT_VALUE: [u8; 13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 13;
    pub const FIELD_SIZES: [usize; 2] = [12, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> StructIx3 {
        StructIx3::new_unchecked(self.0.slice(0..12))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn as_reader<'r>(&'r self) -> StructOReader<'r> {
        StructOReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructO {
    type Builder = StructOBuilder;
    const NAME: &'static str = "StructO";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructO(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructOReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructOReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().f1(self.f1()).f2(self.f2())
    }
}
#[derive(Clone, Copy)]
pub struct StructOReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructOReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructOReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructOReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl<'r> StructOReader<'r> {
    pub const TOTAL_SIZE: usize = 13;
    pub const FIELD_SIZES: [usize; 2] = [12, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> StructIx3Reader<'r> {
        StructIx3Reader::new_unchecked(&self.as_slice()[0..12])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructOReader<'r> {
    type Entity = StructO;
    const NAME: &'static str = "StructOReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructOReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructOBuilder {
    pub(crate) f1: StructIx3,
    pub(crate) f2: Byte,
}
impl StructOBuilder {
    pub const TOTAL_SIZE: usize = 13;
    pub const FIELD_SIZES: [usize; 2] = [12, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(mut self, v: StructIx3) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
}
impl molecule::prelude::Builder for StructOBuilder {
    type Entity = StructO;
    const NAME: &'static str = "StructOBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructO::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructP(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for StructP {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructP::new_unchecked(v)
    }
}
impl StructP {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 2] = [7, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> StructJ {
        StructJ::new_unchecked(self.0.slice(0..7))
    }
    pub fn f2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn as_reader<'r>(&'r self) -> StructPReader<'r> {
        StructPReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructP {
    type Builder = StructPBuilder;
    const NAME: &'static str = "StructP";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructP(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructPReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructPReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().f1(self.f1()).f2(self.f2())
    }
}
#[derive(Clone, Copy)]
pub struct StructPReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructPReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructPReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructPReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, " }}")
    }
}
impl<'r> StructPReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 2] = [7, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(&self) -> StructJReader<'r> {
        StructJReader::new_unchecked(&self.as_slice()[0..7])
    }
    pub fn f2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructPReader<'r> {
    type Entity = StructP;
    const NAME: &'static str = "StructPReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructPReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructPBuilder {
    pub(crate) f1: StructJ,
    pub(crate) f2: Byte,
}
impl StructPBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 2] = [7, 1];
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(mut self, v: StructJ) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte) -> Self {
        self.f2 = v;
        self
    }
}
impl molecule::prelude::Builder for StructPBuilder {
    type Entity = StructP;
    const NAME: &'static str = "StructPBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructP::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bytes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Bytes::new_unchecked(v)
    }
}
impl Bytes {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    const NAME: &'static str = "Bytes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BytesReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    const NAME: &'static str = "BytesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<Byte>);
impl BytesBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte) -> Option<Byte> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    const NAME: &'static str = "BytesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bytes::new_unchecked(inner.into())
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::core::iter::Iterator for BytesIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Bytes {
    type Item = Byte;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct Words(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Words {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Words {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Words {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Words {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Words::new_unchecked(v)
    }
}
impl Words {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Word> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Word {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Word::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> WordsReader<'r> {
        WordsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Words {
    type Builder = WordsBuilder;
    const NAME: &'static str = "Words";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Words(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct WordsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> WordsReader<'r> {
    pub const ITEM_SIZE: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<WordReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> WordReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        WordReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordsReader<'r> {
    type Entity = Words;
    const NAME: &'static str = "WordsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordsBuilder(pub(crate) Vec<Word>);
impl WordsBuilder {
    pub const ITEM_SIZE: usize = 2;
    pub fn set(mut self, v: Vec<Word>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Word) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Word>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Word) -> Option<Word> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for WordsBuilder {
    type Entity = Words;
    const NAME: &'static str = "WordsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Words::new_unchecked(inner.into())
    }
}
pub struct WordsIterator(Words, usize, usize);
impl ::core::iter::Iterator for WordsIterator {
    type Item = Word;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for WordsIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Words {
    type Item = Word;
    type IntoIter = WordsIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        WordsIterator(self, 0, len)
    }
}
impl<'r> WordsReader<'r> {
    pub fn iter<'t>(&'t self) -> WordsReaderIterator<'t, 'r> {
        WordsReaderIterator(&self, 0, self.len())
    }
}
pub struct WordsReaderIterator<'t, 'r>(&'t WordsReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for WordsReaderIterator<'t, 'r> {
    type Item = WordReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for WordsReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Byte3Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte3Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte3Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte3Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Byte3Vec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte3Vec::new_unchecked(v)
    }
}
impl Byte3Vec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte3> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte3 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte3::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Byte3VecReader<'r> {
        Byte3VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte3Vec {
    type Builder = Byte3VecBuilder;
    const NAME: &'static str = "Byte3Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte3Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte3VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte3VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Byte3VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte3VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte3VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte3VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Byte3VecReader<'r> {
    pub const ITEM_SIZE: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte3Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte3Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte3Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte3VecReader<'r> {
    type Entity = Byte3Vec;
    const NAME: &'static str = "Byte3VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte3VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Byte3VecBuilder(pub(crate) Vec<Byte3>);
impl Byte3VecBuilder {
    pub const ITEM_SIZE: usize = 3;
    pub fn set(mut self, v: Vec<Byte3>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte3) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte3>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte3) -> Option<Byte3> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Byte3VecBuilder {
    type Entity = Byte3Vec;
    const NAME: &'static str = "Byte3VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte3Vec::new_unchecked(inner.into())
    }
}
pub struct Byte3VecIterator(Byte3Vec, usize, usize);
impl ::core::iter::Iterator for Byte3VecIterator {
    type Item = Byte3;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Byte3VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Byte3Vec {
    type Item = Byte3;
    type IntoIter = Byte3VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Byte3VecIterator(self, 0, len)
    }
}
impl<'r> Byte3VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Byte3VecReaderIterator<'t, 'r> {
        Byte3VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Byte3VecReaderIterator<'t, 'r>(&'t Byte3VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Byte3VecReaderIterator<'t, 'r> {
    type Item = Byte3Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Byte3VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Byte7Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte7Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte7Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte7Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Byte7Vec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte7Vec::new_unchecked(v)
    }
}
impl Byte7Vec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte7> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte7 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte7::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Byte7VecReader<'r> {
        Byte7VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte7Vec {
    type Builder = Byte7VecBuilder;
    const NAME: &'static str = "Byte7Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte7Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte7VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte7VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Byte7VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte7VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte7VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte7VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Byte7VecReader<'r> {
    pub const ITEM_SIZE: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte7Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte7Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte7Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte7VecReader<'r> {
    type Entity = Byte7Vec;
    const NAME: &'static str = "Byte7VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte7VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Byte7VecBuilder(pub(crate) Vec<Byte7>);
impl Byte7VecBuilder {
    pub const ITEM_SIZE: usize = 7;
    pub fn set(mut self, v: Vec<Byte7>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Byte7) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte7>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Byte7) -> Option<Byte7> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Byte7VecBuilder {
    type Entity = Byte7Vec;
    const NAME: &'static str = "Byte7VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte7Vec::new_unchecked(inner.into())
    }
}
pub struct Byte7VecIterator(Byte7Vec, usize, usize);
impl ::core::iter::Iterator for Byte7VecIterator {
    type Item = Byte7;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Byte7VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Byte7Vec {
    type Item = Byte7;
    type IntoIter = Byte7VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Byte7VecIterator(self, 0, len)
    }
}
impl<'r> Byte7VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Byte7VecReaderIterator<'t, 'r> {
        Byte7VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Byte7VecReaderIterator<'t, 'r>(&'t Byte7VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Byte7VecReaderIterator<'t, 'r> {
    type Item = Byte7Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Byte7VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct StructIVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructIVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructIVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructIVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for StructIVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructIVec::new_unchecked(v)
    }
}
impl StructIVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StructI> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StructI {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        StructI::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> StructIVecReader<'r> {
        StructIVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructIVec {
    type Builder = StructIVecBuilder;
    const NAME: &'static str = "StructIVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructIVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructIVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructIVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct StructIVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructIVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructIVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructIVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> StructIVecReader<'r> {
    pub const ITEM_SIZE: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StructIReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StructIReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        StructIReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructIVecReader<'r> {
    type Entity = StructIVec;
    const NAME: &'static str = "StructIVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructIVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructIVecBuilder(pub(crate) Vec<StructI>);
impl StructIVecBuilder {
    pub const ITEM_SIZE: usize = 4;
    pub fn set(mut self, v: Vec<StructI>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: StructI) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = StructI>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: StructI) -> Option<StructI> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for StructIVecBuilder {
    type Entity = StructIVec;
    const NAME: &'static str = "StructIVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructIVec::new_unchecked(inner.into())
    }
}
pub struct StructIVecIterator(StructIVec, usize, usize);
impl ::core::iter::Iterator for StructIVecIterator {
    type Item = StructI;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for StructIVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for StructIVec {
    type Item = StructI;
    type IntoIter = StructIVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StructIVecIterator(self, 0, len)
    }
}
impl<'r> StructIVecReader<'r> {
    pub fn iter<'t>(&'t self) -> StructIVecReaderIterator<'t, 'r> {
        StructIVecReaderIterator(&self, 0, self.len())
    }
}
pub struct StructIVecReaderIterator<'t, 'r>(&'t StructIVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for StructIVecReaderIterator<'t, 'r> {
    type Item = StructIReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for StructIVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct StructJVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructJVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructJVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructJVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for StructJVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructJVec::new_unchecked(v)
    }
}
impl StructJVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StructJ> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StructJ {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        StructJ::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> StructJVecReader<'r> {
        StructJVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructJVec {
    type Builder = StructJVecBuilder;
    const NAME: &'static str = "StructJVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructJVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructJVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructJVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct StructJVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructJVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructJVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructJVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> StructJVecReader<'r> {
    pub const ITEM_SIZE: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StructJReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StructJReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        StructJReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructJVecReader<'r> {
    type Entity = StructJVec;
    const NAME: &'static str = "StructJVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructJVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructJVecBuilder(pub(crate) Vec<StructJ>);
impl StructJVecBuilder {
    pub const ITEM_SIZE: usize = 7;
    pub fn set(mut self, v: Vec<StructJ>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: StructJ) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = StructJ>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: StructJ) -> Option<StructJ> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for StructJVecBuilder {
    type Entity = StructJVec;
    const NAME: &'static str = "StructJVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructJVec::new_unchecked(inner.into())
    }
}
pub struct StructJVecIterator(StructJVec, usize, usize);
impl ::core::iter::Iterator for StructJVecIterator {
    type Item = StructJ;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for StructJVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for StructJVec {
    type Item = StructJ;
    type IntoIter = StructJVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StructJVecIterator(self, 0, len)
    }
}
impl<'r> StructJVecReader<'r> {
    pub fn iter<'t>(&'t self) -> StructJVecReaderIterator<'t, 'r> {
        StructJVecReaderIterator(&self, 0, self.len())
    }
}
pub struct StructJVecReaderIterator<'t, 'r>(&'t StructJVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for StructJVecReaderIterator<'t, 'r> {
    type Item = StructJReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for StructJVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct StructPVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructPVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructPVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructPVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for StructPVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructPVec::new_unchecked(v)
    }
}
impl StructPVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StructP> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StructP {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        StructP::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> StructPVecReader<'r> {
        StructPVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructPVec {
    type Builder = StructPVecBuilder;
    const NAME: &'static str = "StructPVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructPVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructPVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructPVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct StructPVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructPVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructPVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructPVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> StructPVecReader<'r> {
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StructPReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StructPReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        StructPReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructPVecReader<'r> {
    type Entity = StructPVec;
    const NAME: &'static str = "StructPVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructPVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructPVecBuilder(pub(crate) Vec<StructP>);
impl StructPVecBuilder {
    pub const ITEM_SIZE: usize = 8;
    pub fn set(mut self, v: Vec<StructP>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: StructP) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = StructP>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: StructP) -> Option<StructP> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for StructPVecBuilder {
    type Entity = StructPVec;
    const NAME: &'static str = "StructPVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructPVec::new_unchecked(inner.into())
    }
}
pub struct StructPVecIterator(StructPVec, usize, usize);
impl ::core::iter::Iterator for StructPVecIterator {
    type Item = StructP;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for StructPVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for StructPVec {
    type Item = StructP;
    type IntoIter = StructPVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StructPVecIterator(self, 0, len)
    }
}
impl<'r> StructPVecReader<'r> {
    pub fn iter<'t>(&'t self) -> StructPVecReaderIterator<'t, 'r> {
        StructPVecReaderIterator(&self, 0, self.len())
    }
}
pub struct StructPVecReaderIterator<'t, 'r>(&'t StructPVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for StructPVecReaderIterator<'t, 'r> {
    type Item = StructPReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for StructPVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct BytesVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BytesVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BytesVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BytesVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for BytesVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BytesVec::new_unchecked(v)
    }
}
impl BytesVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Bytes> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Bytes {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Bytes::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BytesVecReader<'r> {
        BytesVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BytesVec {
    type Builder = BytesVecBuilder;
    const NAME: &'static str = "BytesVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BytesVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BytesVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> BytesVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BytesReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesVecReader<'r> {
    type Entity = BytesVec;
    const NAME: &'static str = "BytesVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            BytesReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesVecBuilder(pub(crate) Vec<Bytes>);
impl BytesVecBuilder {
    pub fn set(mut self, v: Vec<Bytes>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Bytes) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Bytes>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Bytes) -> Option<Bytes> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BytesVecBuilder {
    type Entity = BytesVec;
    const NAME: &'static str = "BytesVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BytesVec::new_unchecked(inner.into())
    }
}
pub struct BytesVecIterator(BytesVec, usize, usize);
impl ::core::iter::Iterator for BytesVecIterator {
    type Item = Bytes;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BytesVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for BytesVec {
    type Item = Bytes;
    type IntoIter = BytesVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesVecIterator(self, 0, len)
    }
}
impl<'r> BytesVecReader<'r> {
    pub fn iter<'t>(&'t self) -> BytesVecReaderIterator<'t, 'r> {
        BytesVecReaderIterator(&self, 0, self.len())
    }
}
pub struct BytesVecReaderIterator<'t, 'r>(&'t BytesVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for BytesVecReaderIterator<'t, 'r> {
    type Item = BytesReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for BytesVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct WordsVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WordsVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WordsVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WordsVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for WordsVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WordsVec::new_unchecked(v)
    }
}
impl WordsVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Words> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Words {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Words::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Words::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WordsVecReader<'r> {
        WordsVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WordsVec {
    type Builder = WordsVecBuilder;
    const NAME: &'static str = "WordsVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WordsVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct WordsVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordsVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordsVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordsVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> WordsVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<WordsReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> WordsReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            WordsReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            WordsReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordsVecReader<'r> {
    type Entity = WordsVec;
    const NAME: &'static str = "WordsVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordsVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            WordsReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordsVecBuilder(pub(crate) Vec<Words>);
impl WordsVecBuilder {
    pub fn set(mut self, v: Vec<Words>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Words) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Words>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Words) -> Option<Words> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for WordsVecBuilder {
    type Entity = WordsVec;
    const NAME: &'static str = "WordsVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WordsVec::new_unchecked(inner.into())
    }
}
pub struct WordsVecIterator(WordsVec, usize, usize);
impl ::core::iter::Iterator for WordsVecIterator {
    type Item = Words;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for WordsVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for WordsVec {
    type Item = Words;
    type IntoIter = WordsVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        WordsVecIterator(self, 0, len)
    }
}
impl<'r> WordsVecReader<'r> {
    pub fn iter<'t>(&'t self) -> WordsVecReaderIterator<'t, 'r> {
        WordsVecReaderIterator(&self, 0, self.len())
    }
}
pub struct WordsVecReaderIterator<'t, 'r>(&'t WordsVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for WordsVecReaderIterator<'t, 'r> {
    type Item = WordsReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for WordsVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Table0(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table0 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table0::new_unchecked(v)
    }
}
impl Table0 {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn as_reader<'r>(&'r self) -> Table0Reader<'r> {
        Table0Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table0 {
    type Builder = Table0Builder;
    const NAME: &'static str = "Table0";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table0(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table0Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table0Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
    }
}
#[derive(Clone, Copy)]
pub struct Table0Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table0Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table0Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table0Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table0Reader<'r> {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table0Reader<'r> {
    type Entity = Table0;
    const NAME: &'static str = "Table0Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table0Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len > molecule::NUMBER_SIZE && !compatible {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, !0);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table0Builder {}
impl Table0Builder {
    pub const FIELD_COUNT: usize = 0;
}
impl molecule::prelude::Builder for Table0Builder {
    type Entity = Table0;
    const NAME: &'static str = "Table0Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(
            molecule::NUMBER_SIZE as molecule::Number,
        ))?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table0::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table1 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table1::new_unchecked(v)
    }
}
impl Table1 {
    const DEFAULT_VALUE: [u8; 9] = [9, 0, 0, 0, 8, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table1Reader<'r> {
        Table1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table1 {
    type Builder = Table1Builder;
    const NAME: &'static str = "Table1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().f1(self.f1())
    }
}
#[derive(Clone, Copy)]
pub struct Table1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table1Reader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table1Reader<'r> {
    type Entity = Table1;
    const NAME: &'static str = "Table1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table1Builder {
    pub(crate) f1: Byte,
}
impl Table1Builder {
    pub const FIELD_COUNT: usize = 1;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
}
impl molecule::prelude::Builder for Table1Builder {
    type Entity = Table1;
    const NAME: &'static str = "Table1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.f1.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table2(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table2 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table2::new_unchecked(v)
    }
}
impl Table2 {
    const DEFAULT_VALUE: [u8; 17] = [17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Word2::new_unchecked(self.0.slice(start..end))
        } else {
            Word2::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table2Reader<'r> {
        Table2Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table2 {
    type Builder = Table2Builder;
    const NAME: &'static str = "Table2";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table2(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table2Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table2Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().f1(self.f1()).f2(self.f2())
    }
}
#[derive(Clone, Copy)]
pub struct Table2Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table2Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table2Reader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Word2Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Word2Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table2Reader<'r> {
    type Entity = Table2;
    const NAME: &'static str = "Table2Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table2Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Word2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table2Builder {
    pub(crate) f1: Byte,
    pub(crate) f2: Word2,
}
impl Table2Builder {
    pub const FIELD_COUNT: usize = 2;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Word2) -> Self {
        self.f2 = v;
        self
    }
}
impl molecule::prelude::Builder for Table2Builder {
    type Entity = Table2;
    const NAME: &'static str = "Table2Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table2::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table3(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table3 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table3::new_unchecked(v)
    }
}
impl Table3 {
    const DEFAULT_VALUE: [u8; 27] = [
        27, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f3(&self) -> StructA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            StructA::new_unchecked(self.0.slice(start..end))
        } else {
            StructA::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table3Reader<'r> {
        Table3Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table3 {
    type Builder = Table3Builder;
    const NAME: &'static str = "Table3";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table3(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table3Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table3Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
    }
}
#[derive(Clone, Copy)]
pub struct Table3Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table3Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table3Reader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f3(&self) -> StructAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            StructAReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            StructAReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table3Reader<'r> {
    type Entity = Table3;
    const NAME: &'static str = "Table3Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table3Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Word2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        StructAReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table3Builder {
    pub(crate) f1: Byte,
    pub(crate) f2: Word2,
    pub(crate) f3: StructA,
}
impl Table3Builder {
    pub const FIELD_COUNT: usize = 3;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Word2) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: StructA) -> Self {
        self.f3 = v;
        self
    }
}
impl molecule::prelude::Builder for Table3Builder {
    type Entity = Table3;
    const NAME: &'static str = "Table3Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
            + self.f3.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        offsets.push(total_size);
        total_size += self.f3.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table3::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table4(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table4 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table4::new_unchecked(v)
    }
}
impl Table4 {
    const DEFAULT_VALUE: [u8; 35] = [
        35, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 25, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f3(&self) -> StructA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        StructA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f4(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table4Reader<'r> {
        Table4Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table4 {
    type Builder = Table4Builder;
    const NAME: &'static str = "Table4";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table4(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table4Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table4Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
    }
}
#[derive(Clone, Copy)]
pub struct Table4Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table4Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table4Reader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f3(&self) -> StructAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        StructAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f4(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table4Reader<'r> {
    type Entity = Table4;
    const NAME: &'static str = "Table4Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table4Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Word2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        StructAReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BytesReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table4Builder {
    pub(crate) f1: Byte,
    pub(crate) f2: Word2,
    pub(crate) f3: StructA,
    pub(crate) f4: Bytes,
}
impl Table4Builder {
    pub const FIELD_COUNT: usize = 4;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Word2) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: StructA) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Bytes) -> Self {
        self.f4 = v;
        self
    }
}
impl molecule::prelude::Builder for Table4Builder {
    type Entity = Table4;
    const NAME: &'static str = "Table4Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
            + self.f3.as_slice().len()
            + self.f4.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        offsets.push(total_size);
        total_size += self.f3.as_slice().len();
        offsets.push(total_size);
        total_size += self.f4.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table4::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table5(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table5 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table5::new_unchecked(v)
    }
}
impl Table5 {
    const DEFAULT_VALUE: [u8; 43] = [
        43, 0, 0, 0, 24, 0, 0, 0, 25, 0, 0, 0, 29, 0, 0, 0, 35, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f3(&self) -> StructA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        StructA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f4(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn f5(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table5Reader<'r> {
        Table5Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table5 {
    type Builder = Table5Builder;
    const NAME: &'static str = "Table5";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table5(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table5Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table5Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
            .f5(self.f5())
    }
}
#[derive(Clone, Copy)]
pub struct Table5Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table5Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table5Reader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f3(&self) -> StructAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        StructAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f4(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f5(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table5Reader<'r> {
    type Entity = Table5;
    const NAME: &'static str = "Table5Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table5Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Word2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        StructAReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BytesReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BytesVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table5Builder {
    pub(crate) f1: Byte,
    pub(crate) f2: Word2,
    pub(crate) f3: StructA,
    pub(crate) f4: Bytes,
    pub(crate) f5: BytesVec,
}
impl Table5Builder {
    pub const FIELD_COUNT: usize = 5;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Word2) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: StructA) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Bytes) -> Self {
        self.f4 = v;
        self
    }
    pub fn f5(mut self, v: BytesVec) -> Self {
        self.f5 = v;
        self
    }
}
impl molecule::prelude::Builder for Table5Builder {
    type Entity = Table5;
    const NAME: &'static str = "Table5Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
            + self.f3.as_slice().len()
            + self.f4.as_slice().len()
            + self.f5.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        offsets.push(total_size);
        total_size += self.f3.as_slice().len();
        offsets.push(total_size);
        total_size += self.f4.as_slice().len();
        offsets.push(total_size);
        total_size += self.f5.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        writer.write_all(self.f5.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table5::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table6(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        write!(f, ", {}: {}", "f6", self.f6())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Table6 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table6::new_unchecked(v)
    }
}
impl Table6 {
    const DEFAULT_VALUE: [u8; 90] = [
        90, 0, 0, 0, 28, 0, 0, 0, 29, 0, 0, 0, 33, 0, 0, 0, 39, 0, 0, 0, 43, 0, 0, 0, 47, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 43, 0, 0, 0, 24, 0, 0, 0, 25, 0,
        0, 0, 29, 0, 0, 0, 35, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f3(&self) -> StructA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        StructA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f4(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn f5(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        BytesVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f6(&self) -> Table5 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Table5::new_unchecked(self.0.slice(start..end))
        } else {
            Table5::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table6Reader<'r> {
        Table6Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table6 {
    type Builder = Table6Builder;
    const NAME: &'static str = "Table6";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table6(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table6Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table6Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
            .f5(self.f5())
            .f6(self.f6())
    }
}
#[derive(Clone, Copy)]
pub struct Table6Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table6Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        write!(f, ", {}: {}", "f6", self.f6())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> Table6Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Word2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f3(&self) -> StructAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        StructAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f4(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f5(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        BytesVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f6(&self) -> Table5Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Table5Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Table5Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table6Reader<'r> {
    type Entity = Table6;
    const NAME: &'static str = "Table6Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table6Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Word2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        StructAReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BytesReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BytesVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Table5Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table6Builder {
    pub(crate) f1: Byte,
    pub(crate) f2: Word2,
    pub(crate) f3: StructA,
    pub(crate) f4: Bytes,
    pub(crate) f5: BytesVec,
    pub(crate) f6: Table5,
}
impl Table6Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn f1(mut self, v: Byte) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Word2) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: StructA) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Bytes) -> Self {
        self.f4 = v;
        self
    }
    pub fn f5(mut self, v: BytesVec) -> Self {
        self.f5 = v;
        self
    }
    pub fn f6(mut self, v: Table5) -> Self {
        self.f6 = v;
        self
    }
}
impl molecule::prelude::Builder for Table6Builder {
    type Entity = Table6;
    const NAME: &'static str = "Table6Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
            + self.f3.as_slice().len()
            + self.f4.as_slice().len()
            + self.f5.as_slice().len()
            + self.f6.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        offsets.push(total_size);
        total_size += self.f3.as_slice().len();
        offsets.push(total_size);
        total_size += self.f4.as_slice().len();
        offsets.push(total_size);
        total_size += self.f5.as_slice().len();
        offsets.push(total_size);
        total_size += self.f6.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        writer.write_all(self.f5.as_slice())?;
        writer.write_all(self.f6.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table6::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ByteOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ByteOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ByteOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ByteOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for ByteOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ByteOpt::new_unchecked(v)
    }
}
impl ByteOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte> {
        if self.is_none() {
            None
        } else {
            Some(Byte::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ByteOptReader<'r> {
        ByteOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ByteOpt {
    type Builder = ByteOptBuilder;
    const NAME: &'static str = "ByteOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ByteOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ByteOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ByteOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct ByteOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ByteOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ByteOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ByteOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> ByteOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<ByteReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(ByteReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ByteOptReader<'r> {
    type Entity = ByteOpt;
    const NAME: &'static str = "ByteOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ByteOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            ByteReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ByteOptBuilder(pub(crate) Option<Byte>);
impl ByteOptBuilder {
    pub fn set(mut self, v: Option<Byte>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for ByteOptBuilder {
    type Entity = ByteOpt;
    const NAME: &'static str = "ByteOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ByteOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct WordOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WordOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WordOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WordOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for WordOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WordOpt::new_unchecked(v)
    }
}
impl WordOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Word> {
        if self.is_none() {
            None
        } else {
            Some(Word::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WordOptReader<'r> {
        WordOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WordOpt {
    type Builder = WordOptBuilder;
    const NAME: &'static str = "WordOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WordOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct WordOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> WordOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<WordReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(WordReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordOptReader<'r> {
    type Entity = WordOpt;
    const NAME: &'static str = "WordOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            WordReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordOptBuilder(pub(crate) Option<Word>);
impl WordOptBuilder {
    pub fn set(mut self, v: Option<Word>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for WordOptBuilder {
    type Entity = WordOpt;
    const NAME: &'static str = "WordOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WordOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructAOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructAOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructAOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructAOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for StructAOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructAOpt::new_unchecked(v)
    }
}
impl StructAOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<StructA> {
        if self.is_none() {
            None
        } else {
            Some(StructA::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> StructAOptReader<'r> {
        StructAOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructAOpt {
    type Builder = StructAOptBuilder;
    const NAME: &'static str = "StructAOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructAOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructAOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructAOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct StructAOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructAOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructAOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructAOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> StructAOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<StructAReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(StructAReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructAOptReader<'r> {
    type Entity = StructAOpt;
    const NAME: &'static str = "StructAOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructAOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            StructAReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructAOptBuilder(pub(crate) Option<StructA>);
impl StructAOptBuilder {
    pub fn set(mut self, v: Option<StructA>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for StructAOptBuilder {
    type Entity = StructAOpt;
    const NAME: &'static str = "StructAOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructAOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct StructPOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for StructPOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for StructPOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for StructPOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for StructPOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        StructPOpt::new_unchecked(v)
    }
}
impl StructPOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<StructP> {
        if self.is_none() {
            None
        } else {
            Some(StructP::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> StructPOptReader<'r> {
        StructPOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for StructPOpt {
    type Builder = StructPOptBuilder;
    const NAME: &'static str = "StructPOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StructPOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructPOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StructPOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct StructPOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for StructPOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for StructPOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for StructPOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> StructPOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<StructPReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(StructPReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for StructPOptReader<'r> {
    type Entity = StructPOpt;
    const NAME: &'static str = "StructPOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StructPOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            StructPReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct StructPOptBuilder(pub(crate) Option<StructP>);
impl StructPOptBuilder {
    pub fn set(mut self, v: Option<StructP>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for StructPOptBuilder {
    type Entity = StructPOpt;
    const NAME: &'static str = "StructPOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        StructPOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BytesOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BytesOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BytesOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BytesOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for BytesOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BytesOpt::new_unchecked(v)
    }
}
impl BytesOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Bytes> {
        if self.is_none() {
            None
        } else {
            Some(Bytes::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BytesOptReader<'r> {
        BytesOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BytesOpt {
    type Builder = BytesOptBuilder;
    const NAME: &'static str = "BytesOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BytesOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct BytesOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> BytesOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BytesReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BytesReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesOptReader<'r> {
    type Entity = BytesOpt;
    const NAME: &'static str = "BytesOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BytesReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesOptBuilder(pub(crate) Option<Bytes>);
impl BytesOptBuilder {
    pub fn set(mut self, v: Option<Bytes>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for BytesOptBuilder {
    type Entity = BytesOpt;
    const NAME: &'static str = "BytesOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BytesOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct WordsOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WordsOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WordsOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WordsOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for WordsOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WordsOpt::new_unchecked(v)
    }
}
impl WordsOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Words> {
        if self.is_none() {
            None
        } else {
            Some(Words::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WordsOptReader<'r> {
        WordsOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WordsOpt {
    type Builder = WordsOptBuilder;
    const NAME: &'static str = "WordsOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WordsOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct WordsOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordsOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordsOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordsOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> WordsOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<WordsReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(WordsReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordsOptReader<'r> {
    type Entity = WordsOpt;
    const NAME: &'static str = "WordsOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordsOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            WordsReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordsOptBuilder(pub(crate) Option<Words>);
impl WordsOptBuilder {
    pub fn set(mut self, v: Option<Words>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for WordsOptBuilder {
    type Entity = WordsOpt;
    const NAME: &'static str = "WordsOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WordsOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BytesVecOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BytesVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BytesVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BytesVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for BytesVecOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BytesVecOpt::new_unchecked(v)
    }
}
impl BytesVecOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BytesVec> {
        if self.is_none() {
            None
        } else {
            Some(BytesVec::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BytesVecOptReader<'r> {
        BytesVecOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BytesVecOpt {
    type Builder = BytesVecOptBuilder;
    const NAME: &'static str = "BytesVecOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BytesVecOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesVecOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesVecOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct BytesVecOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> BytesVecOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BytesVecReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BytesVecReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesVecOptReader<'r> {
    type Entity = BytesVecOpt;
    const NAME: &'static str = "BytesVecOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesVecOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BytesVecReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesVecOptBuilder(pub(crate) Option<BytesVec>);
impl BytesVecOptBuilder {
    pub fn set(mut self, v: Option<BytesVec>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for BytesVecOptBuilder {
    type Entity = BytesVecOpt;
    const NAME: &'static str = "BytesVecOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BytesVecOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct WordsVecOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WordsVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WordsVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WordsVecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for WordsVecOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WordsVecOpt::new_unchecked(v)
    }
}
impl WordsVecOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<WordsVec> {
        if self.is_none() {
            None
        } else {
            Some(WordsVec::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WordsVecOptReader<'r> {
        WordsVecOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WordsVecOpt {
    type Builder = WordsVecOptBuilder;
    const NAME: &'static str = "WordsVecOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WordsVecOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsVecOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsVecOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct WordsVecOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordsVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordsVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordsVecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> WordsVecOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<WordsVecReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(WordsVecReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordsVecOptReader<'r> {
    type Entity = WordsVecOpt;
    const NAME: &'static str = "WordsVecOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordsVecOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            WordsVecReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordsVecOptBuilder(pub(crate) Option<WordsVec>);
impl WordsVecOptBuilder {
    pub fn set(mut self, v: Option<WordsVec>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for WordsVecOptBuilder {
    type Entity = WordsVecOpt;
    const NAME: &'static str = "WordsVecOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WordsVecOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table0Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table0Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table0Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table0Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Table0Opt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table0Opt::new_unchecked(v)
    }
}
impl Table0Opt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Table0> {
        if self.is_none() {
            None
        } else {
            Some(Table0::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table0OptReader<'r> {
        Table0OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table0Opt {
    type Builder = Table0OptBuilder;
    const NAME: &'static str = "Table0Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table0Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table0OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table0OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Table0OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table0OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table0OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table0OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Table0OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Table0Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Table0Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table0OptReader<'r> {
    type Entity = Table0Opt;
    const NAME: &'static str = "Table0OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table0OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Table0Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table0OptBuilder(pub(crate) Option<Table0>);
impl Table0OptBuilder {
    pub fn set(mut self, v: Option<Table0>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Table0OptBuilder {
    type Entity = Table0Opt;
    const NAME: &'static str = "Table0OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table0Opt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table6Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table6Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table6Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table6Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Table6Opt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table6Opt::new_unchecked(v)
    }
}
impl Table6Opt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Table6> {
        if self.is_none() {
            None
        } else {
            Some(Table6::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table6OptReader<'r> {
        Table6OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table6Opt {
    type Builder = Table6OptBuilder;
    const NAME: &'static str = "Table6Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table6Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table6OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table6OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Table6OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table6OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table6OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table6OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Table6OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Table6Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Table6Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table6OptReader<'r> {
    type Entity = Table6Opt;
    const NAME: &'static str = "Table6OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table6OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Table6Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table6OptBuilder(pub(crate) Option<Table6>);
impl Table6OptBuilder {
    pub fn set(mut self, v: Option<Table6>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Table6OptBuilder {
    type Entity = Table6Opt;
    const NAME: &'static str = "Table6OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table6Opt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Table6OptOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Table6OptOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Table6OptOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Table6OptOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Table6OptOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Table6OptOpt::new_unchecked(v)
    }
}
impl Table6OptOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Table6Opt> {
        if self.is_none() {
            None
        } else {
            Some(Table6Opt::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Table6OptOptReader<'r> {
        Table6OptOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Table6OptOpt {
    type Builder = Table6OptOptBuilder;
    const NAME: &'static str = "Table6OptOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Table6OptOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table6OptOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Table6OptOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Table6OptOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Table6OptOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Table6OptOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Table6OptOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Table6OptOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Table6OptReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Table6OptReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Table6OptOptReader<'r> {
    type Entity = Table6OptOpt;
    const NAME: &'static str = "Table6OptOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Table6OptOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Table6OptReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct Table6OptOptBuilder(pub(crate) Option<Table6Opt>);
impl Table6OptOptBuilder {
    pub fn set(mut self, v: Option<Table6Opt>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Table6OptOptBuilder {
    type Entity = Table6OptOpt;
    const NAME: &'static str = "Table6OptOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Table6OptOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ByteOptVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ByteOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ByteOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ByteOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for ByteOptVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ByteOptVec::new_unchecked(v)
    }
}
impl ByteOptVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteOpt> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteOpt {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ByteOpt::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ByteOpt::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ByteOptVecReader<'r> {
        ByteOptVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ByteOptVec {
    type Builder = ByteOptVecBuilder;
    const NAME: &'static str = "ByteOptVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ByteOptVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ByteOptVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ByteOptVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ByteOptVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ByteOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ByteOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ByteOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ByteOptVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteOptReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteOptReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            ByteOptReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            ByteOptReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ByteOptVecReader<'r> {
    type Entity = ByteOptVec;
    const NAME: &'static str = "ByteOptVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ByteOptVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            ByteOptReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ByteOptVecBuilder(pub(crate) Vec<ByteOpt>);
impl ByteOptVecBuilder {
    pub fn set(mut self, v: Vec<ByteOpt>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: ByteOpt) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = ByteOpt>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: ByteOpt) -> Option<ByteOpt> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for ByteOptVecBuilder {
    type Entity = ByteOptVec;
    const NAME: &'static str = "ByteOptVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ByteOptVec::new_unchecked(inner.into())
    }
}
pub struct ByteOptVecIterator(ByteOptVec, usize, usize);
impl ::core::iter::Iterator for ByteOptVecIterator {
    type Item = ByteOpt;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ByteOptVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for ByteOptVec {
    type Item = ByteOpt;
    type IntoIter = ByteOptVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ByteOptVecIterator(self, 0, len)
    }
}
impl<'r> ByteOptVecReader<'r> {
    pub fn iter<'t>(&'t self) -> ByteOptVecReaderIterator<'t, 'r> {
        ByteOptVecReaderIterator(&self, 0, self.len())
    }
}
pub struct ByteOptVecReaderIterator<'t, 'r>(&'t ByteOptVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for ByteOptVecReaderIterator<'t, 'r> {
    type Item = ByteOptReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for ByteOptVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct WordOptVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WordOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WordOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WordOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for WordOptVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WordOptVec::new_unchecked(v)
    }
}
impl WordOptVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<WordOpt> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> WordOpt {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            WordOpt::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            WordOpt::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WordOptVecReader<'r> {
        WordOptVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WordOptVec {
    type Builder = WordOptVecBuilder;
    const NAME: &'static str = "WordOptVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WordOptVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordOptVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordOptVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct WordOptVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> WordOptVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<WordOptReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> WordOptReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            WordOptReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            WordOptReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordOptVecReader<'r> {
    type Entity = WordOptVec;
    const NAME: &'static str = "WordOptVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordOptVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            WordOptReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordOptVecBuilder(pub(crate) Vec<WordOpt>);
impl WordOptVecBuilder {
    pub fn set(mut self, v: Vec<WordOpt>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: WordOpt) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = WordOpt>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: WordOpt) -> Option<WordOpt> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for WordOptVecBuilder {
    type Entity = WordOptVec;
    const NAME: &'static str = "WordOptVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WordOptVec::new_unchecked(inner.into())
    }
}
pub struct WordOptVecIterator(WordOptVec, usize, usize);
impl ::core::iter::Iterator for WordOptVecIterator {
    type Item = WordOpt;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for WordOptVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for WordOptVec {
    type Item = WordOpt;
    type IntoIter = WordOptVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        WordOptVecIterator(self, 0, len)
    }
}
impl<'r> WordOptVecReader<'r> {
    pub fn iter<'t>(&'t self) -> WordOptVecReaderIterator<'t, 'r> {
        WordOptVecReaderIterator(&self, 0, self.len())
    }
}
pub struct WordOptVecReaderIterator<'t, 'r>(&'t WordOptVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for WordOptVecReaderIterator<'t, 'r> {
    type Item = WordOptReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for WordOptVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct WordsOptVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WordsOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WordsOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WordsOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for WordsOptVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WordsOptVec::new_unchecked(v)
    }
}
impl WordsOptVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<WordsOpt> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> WordsOpt {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            WordsOpt::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            WordsOpt::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WordsOptVecReader<'r> {
        WordsOptVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WordsOptVec {
    type Builder = WordsOptVecBuilder;
    const NAME: &'static str = "WordsOptVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WordsOptVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsOptVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WordsOptVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct WordsOptVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WordsOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WordsOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WordsOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> WordsOptVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<WordsOptReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> WordsOptReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            WordsOptReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            WordsOptReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WordsOptVecReader<'r> {
    type Entity = WordsOptVec;
    const NAME: &'static str = "WordsOptVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WordsOptVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            WordsOptReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WordsOptVecBuilder(pub(crate) Vec<WordsOpt>);
impl WordsOptVecBuilder {
    pub fn set(mut self, v: Vec<WordsOpt>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: WordsOpt) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = WordsOpt>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: WordsOpt) -> Option<WordsOpt> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for WordsOptVecBuilder {
    type Entity = WordsOptVec;
    const NAME: &'static str = "WordsOptVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WordsOptVec::new_unchecked(inner.into())
    }
}
pub struct WordsOptVecIterator(WordsOptVec, usize, usize);
impl ::core::iter::Iterator for WordsOptVecIterator {
    type Item = WordsOpt;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for WordsOptVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for WordsOptVec {
    type Item = WordsOpt;
    type IntoIter = WordsOptVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        WordsOptVecIterator(self, 0, len)
    }
}
impl<'r> WordsOptVecReader<'r> {
    pub fn iter<'t>(&'t self) -> WordsOptVecReaderIterator<'t, 'r> {
        WordsOptVecReaderIterator(&self, 0, self.len())
    }
}
pub struct WordsOptVecReaderIterator<'t, 'r>(&'t WordsOptVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for WordsOptVecReaderIterator<'t, 'r> {
    type Item = WordsOptReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for WordsOptVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct BytesOptVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BytesOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BytesOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BytesOptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for BytesOptVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BytesOptVec::new_unchecked(v)
    }
}
impl BytesOptVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BytesOpt> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BytesOpt {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BytesOpt::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BytesOptVecReader<'r> {
        BytesOptVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BytesOptVec {
    type Builder = BytesOptVecBuilder;
    const NAME: &'static str = "BytesOptVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BytesOptVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesOptVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesOptVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct BytesOptVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BytesOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BytesOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BytesOptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> BytesOptVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BytesOptReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesOptVecReader<'r> {
    type Entity = BytesOptVec;
    const NAME: &'static str = "BytesOptVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesOptVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            BytesOptReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct BytesOptVecBuilder(pub(crate) Vec<BytesOpt>);
impl BytesOptVecBuilder {
    pub fn set(mut self, v: Vec<BytesOpt>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: BytesOpt) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = BytesOpt>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: BytesOpt) -> Option<BytesOpt> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for BytesOptVecBuilder {
    type Entity = BytesOptVec;
    const NAME: &'static str = "BytesOptVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BytesOptVec::new_unchecked(inner.into())
    }
}
pub struct BytesOptVecIterator(BytesOptVec, usize, usize);
impl ::core::iter::Iterator for BytesOptVecIterator {
    type Item = BytesOpt;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for BytesOptVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for BytesOptVec {
    type Item = BytesOpt;
    type IntoIter = BytesOptVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesOptVecIterator(self, 0, len)
    }
}
impl<'r> BytesOptVecReader<'r> {
    pub fn iter<'t>(&'t self) -> BytesOptVecReaderIterator<'t, 'r> {
        BytesOptVecReaderIterator(&self, 0, self.len())
    }
}
pub struct BytesOptVecReaderIterator<'t, 'r>(&'t BytesOptVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for BytesOptVecReaderIterator<'t, 'r> {
    type Item = BytesOptReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for BytesOptVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct UnionA(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UnionA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UnionA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UnionA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for UnionA {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UnionA::new_unchecked(v)
    }
}
impl UnionA {
    const DEFAULT_VALUE: [u8; 5] = [0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionAUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Byte::new_unchecked(inner).into(),
            1 => Word::new_unchecked(inner).into(),
            2 => StructA::new_unchecked(inner).into(),
            3 => Bytes::new_unchecked(inner).into(),
            4 => Words::new_unchecked(inner).into(),
            5 => Table0::new_unchecked(inner).into(),
            6 => Table6::new_unchecked(inner).into(),
            7 => Table6Opt::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionAReader<'r> {
        UnionAReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UnionA {
    type Builder = UnionABuilder;
    const NAME: &'static str = "UnionA";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UnionA(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionAReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionAReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct UnionAReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UnionAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UnionAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UnionAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> UnionAReader<'r> {
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionAUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ByteReader::new_unchecked(inner).into(),
            1 => WordReader::new_unchecked(inner).into(),
            2 => StructAReader::new_unchecked(inner).into(),
            3 => BytesReader::new_unchecked(inner).into(),
            4 => WordsReader::new_unchecked(inner).into(),
            5 => Table0Reader::new_unchecked(inner).into(),
            6 => Table6Reader::new_unchecked(inner).into(),
            7 => Table6OptReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UnionAReader<'r> {
    type Entity = UnionA;
    const NAME: &'static str = "UnionAReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UnionAReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ByteReader::verify(inner_slice, compatible),
            1 => WordReader::verify(inner_slice, compatible),
            2 => StructAReader::verify(inner_slice, compatible),
            3 => BytesReader::verify(inner_slice, compatible),
            4 => WordsReader::verify(inner_slice, compatible),
            5 => Table0Reader::verify(inner_slice, compatible),
            6 => Table6Reader::verify(inner_slice, compatible),
            7 => Table6OptReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UnionABuilder(pub(crate) UnionAUnion);
impl UnionABuilder {
    pub const ITEMS_COUNT: usize = 8;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<UnionAUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for UnionABuilder {
    type Entity = UnionA;
    const NAME: &'static str = "UnionABuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UnionA::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum UnionAUnion {
    Byte(Byte),
    Word(Word),
    StructA(StructA),
    Bytes(Bytes),
    Words(Words),
    Table0(Table0),
    Table6(Table6),
    Table6Opt(Table6Opt),
}
#[derive(Debug, Clone, Copy)]
pub enum UnionAUnionReader<'r> {
    Byte(ByteReader<'r>),
    Word(WordReader<'r>),
    StructA(StructAReader<'r>),
    Bytes(BytesReader<'r>),
    Words(WordsReader<'r>),
    Table0(Table0Reader<'r>),
    Table6(Table6Reader<'r>),
    Table6Opt(Table6OptReader<'r>),
}
impl ::core::default::Default for UnionAUnion {
    fn default() -> Self {
        UnionAUnion::Byte(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for UnionAUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionAUnion::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
            UnionAUnion::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
            UnionAUnion::StructA(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, StructA::NAME, item)
            }
            UnionAUnion::Bytes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Bytes::NAME, item)
            }
            UnionAUnion::Words(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Words::NAME, item)
            }
            UnionAUnion::Table0(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Table0::NAME, item)
            }
            UnionAUnion::Table6(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Table6::NAME, item)
            }
            UnionAUnion::Table6Opt(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Table6Opt::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for UnionAUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionAUnionReader::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
            UnionAUnionReader::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
            UnionAUnionReader::StructA(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, StructA::NAME, item)
            }
            UnionAUnionReader::Bytes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Bytes::NAME, item)
            }
            UnionAUnionReader::Words(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Words::NAME, item)
            }
            UnionAUnionReader::Table0(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Table0::NAME, item)
            }
            UnionAUnionReader::Table6(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Table6::NAME, item)
            }
            UnionAUnionReader::Table6Opt(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Table6Opt::NAME, item)
            }
        }
    }
}
impl UnionAUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionAUnion::Byte(ref item) => write!(f, "{}", item),
            UnionAUnion::Word(ref item) => write!(f, "{}", item),
            UnionAUnion::StructA(ref item) => write!(f, "{}", item),
            UnionAUnion::Bytes(ref item) => write!(f, "{}", item),
            UnionAUnion::Words(ref item) => write!(f, "{}", item),
            UnionAUnion::Table0(ref item) => write!(f, "{}", item),
            UnionAUnion::Table6(ref item) => write!(f, "{}", item),
            UnionAUnion::Table6Opt(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> UnionAUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionAUnionReader::Byte(ref item) => write!(f, "{}", item),
            UnionAUnionReader::Word(ref item) => write!(f, "{}", item),
            UnionAUnionReader::StructA(ref item) => write!(f, "{}", item),
            UnionAUnionReader::Bytes(ref item) => write!(f, "{}", item),
            UnionAUnionReader::Words(ref item) => write!(f, "{}", item),
            UnionAUnionReader::Table0(ref item) => write!(f, "{}", item),
            UnionAUnionReader::Table6(ref item) => write!(f, "{}", item),
            UnionAUnionReader::Table6Opt(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Byte> for UnionAUnion {
    fn from(item: Byte) -> Self {
        UnionAUnion::Byte(item)
    }
}
impl ::core::convert::From<Word> for UnionAUnion {
    fn from(item: Word) -> Self {
        UnionAUnion::Word(item)
    }
}
impl ::core::convert::From<StructA> for UnionAUnion {
    fn from(item: StructA) -> Self {
        UnionAUnion::StructA(item)
    }
}
impl ::core::convert::From<Bytes> for UnionAUnion {
    fn from(item: Bytes) -> Self {
        UnionAUnion::Bytes(item)
    }
}
impl ::core::convert::From<Words> for UnionAUnion {
    fn from(item: Words) -> Self {
        UnionAUnion::Words(item)
    }
}
impl ::core::convert::From<Table0> for UnionAUnion {
    fn from(item: Table0) -> Self {
        UnionAUnion::Table0(item)
    }
}
impl ::core::convert::From<Table6> for UnionAUnion {
    fn from(item: Table6) -> Self {
        UnionAUnion::Table6(item)
    }
}
impl ::core::convert::From<Table6Opt> for UnionAUnion {
    fn from(item: Table6Opt) -> Self {
        UnionAUnion::Table6Opt(item)
    }
}
impl<'r> ::core::convert::From<ByteReader<'r>> for UnionAUnionReader<'r> {
    fn from(item: ByteReader<'r>) -> Self {
        UnionAUnionReader::Byte(item)
    }
}
impl<'r> ::core::convert::From<WordReader<'r>> for UnionAUnionReader<'r> {
    fn from(item: WordReader<'r>) -> Self {
        UnionAUnionReader::Word(item)
    }
}
impl<'r> ::core::convert::From<StructAReader<'r>> for UnionAUnionReader<'r> {
    fn from(item: StructAReader<'r>) -> Self {
        UnionAUnionReader::StructA(item)
    }
}
impl<'r> ::core::convert::From<BytesReader<'r>> for UnionAUnionReader<'r> {
    fn from(item: BytesReader<'r>) -> Self {
        UnionAUnionReader::Bytes(item)
    }
}
impl<'r> ::core::convert::From<WordsReader<'r>> for UnionAUnionReader<'r> {
    fn from(item: WordsReader<'r>) -> Self {
        UnionAUnionReader::Words(item)
    }
}
impl<'r> ::core::convert::From<Table0Reader<'r>> for UnionAUnionReader<'r> {
    fn from(item: Table0Reader<'r>) -> Self {
        UnionAUnionReader::Table0(item)
    }
}
impl<'r> ::core::convert::From<Table6Reader<'r>> for UnionAUnionReader<'r> {
    fn from(item: Table6Reader<'r>) -> Self {
        UnionAUnionReader::Table6(item)
    }
}
impl<'r> ::core::convert::From<Table6OptReader<'r>> for UnionAUnionReader<'r> {
    fn from(item: Table6OptReader<'r>) -> Self {
        UnionAUnionReader::Table6Opt(item)
    }
}
impl UnionAUnion {
    pub const NAME: &'static str = "UnionAUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            UnionAUnion::Byte(item) => item.as_bytes(),
            UnionAUnion::Word(item) => item.as_bytes(),
            UnionAUnion::StructA(item) => item.as_bytes(),
            UnionAUnion::Bytes(item) => item.as_bytes(),
            UnionAUnion::Words(item) => item.as_bytes(),
            UnionAUnion::Table0(item) => item.as_bytes(),
            UnionAUnion::Table6(item) => item.as_bytes(),
            UnionAUnion::Table6Opt(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            UnionAUnion::Byte(item) => item.as_slice(),
            UnionAUnion::Word(item) => item.as_slice(),
            UnionAUnion::StructA(item) => item.as_slice(),
            UnionAUnion::Bytes(item) => item.as_slice(),
            UnionAUnion::Words(item) => item.as_slice(),
            UnionAUnion::Table0(item) => item.as_slice(),
            UnionAUnion::Table6(item) => item.as_slice(),
            UnionAUnion::Table6Opt(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionAUnion::Byte(_) => 0,
            UnionAUnion::Word(_) => 1,
            UnionAUnion::StructA(_) => 2,
            UnionAUnion::Bytes(_) => 3,
            UnionAUnion::Words(_) => 4,
            UnionAUnion::Table0(_) => 5,
            UnionAUnion::Table6(_) => 6,
            UnionAUnion::Table6Opt(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionAUnion::Byte(_) => "Byte",
            UnionAUnion::Word(_) => "Word",
            UnionAUnion::StructA(_) => "StructA",
            UnionAUnion::Bytes(_) => "Bytes",
            UnionAUnion::Words(_) => "Words",
            UnionAUnion::Table0(_) => "Table0",
            UnionAUnion::Table6(_) => "Table6",
            UnionAUnion::Table6Opt(_) => "Table6Opt",
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionAUnionReader<'r> {
        match self {
            UnionAUnion::Byte(item) => item.as_reader().into(),
            UnionAUnion::Word(item) => item.as_reader().into(),
            UnionAUnion::StructA(item) => item.as_reader().into(),
            UnionAUnion::Bytes(item) => item.as_reader().into(),
            UnionAUnion::Words(item) => item.as_reader().into(),
            UnionAUnion::Table0(item) => item.as_reader().into(),
            UnionAUnion::Table6(item) => item.as_reader().into(),
            UnionAUnion::Table6Opt(item) => item.as_reader().into(),
        }
    }
}
impl<'r> UnionAUnionReader<'r> {
    pub const NAME: &'r str = "UnionAUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            UnionAUnionReader::Byte(item) => item.as_slice(),
            UnionAUnionReader::Word(item) => item.as_slice(),
            UnionAUnionReader::StructA(item) => item.as_slice(),
            UnionAUnionReader::Bytes(item) => item.as_slice(),
            UnionAUnionReader::Words(item) => item.as_slice(),
            UnionAUnionReader::Table0(item) => item.as_slice(),
            UnionAUnionReader::Table6(item) => item.as_slice(),
            UnionAUnionReader::Table6Opt(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionAUnionReader::Byte(_) => 0,
            UnionAUnionReader::Word(_) => 1,
            UnionAUnionReader::StructA(_) => 2,
            UnionAUnionReader::Bytes(_) => 3,
            UnionAUnionReader::Words(_) => 4,
            UnionAUnionReader::Table0(_) => 5,
            UnionAUnionReader::Table6(_) => 6,
            UnionAUnionReader::Table6Opt(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionAUnionReader::Byte(_) => "Byte",
            UnionAUnionReader::Word(_) => "Word",
            UnionAUnionReader::StructA(_) => "StructA",
            UnionAUnionReader::Bytes(_) => "Bytes",
            UnionAUnionReader::Words(_) => "Words",
            UnionAUnionReader::Table0(_) => "Table0",
            UnionAUnionReader::Table6(_) => "Table6",
            UnionAUnionReader::Table6Opt(_) => "Table6Opt",
        }
    }
}
#[derive(Clone)]
pub struct UnionB(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UnionB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UnionB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UnionB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for UnionB {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UnionB::new_unchecked(v)
    }
}
impl UnionB {
    const DEFAULT_VALUE: [u8; 5] = [2, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionBUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            2 => Byte::new_unchecked(inner).into(),
            4 => Word::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionBReader<'r> {
        UnionBReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UnionB {
    type Builder = UnionBBuilder;
    const NAME: &'static str = "UnionB";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UnionB(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionBReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionBReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct UnionBReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UnionBReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UnionBReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UnionBReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> UnionBReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionBUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            2 => ByteReader::new_unchecked(inner).into(),
            4 => WordReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UnionBReader<'r> {
    type Entity = UnionB;
    const NAME: &'static str = "UnionBReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UnionBReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            2 => ByteReader::verify(inner_slice, compatible),
            4 => WordReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UnionBBuilder(pub(crate) UnionBUnion);
impl UnionBBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<UnionBUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for UnionBBuilder {
    type Entity = UnionB;
    const NAME: &'static str = "UnionBBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UnionB::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum UnionBUnion {
    Byte(Byte),
    Word(Word),
}
#[derive(Debug, Clone, Copy)]
pub enum UnionBUnionReader<'r> {
    Byte(ByteReader<'r>),
    Word(WordReader<'r>),
}
impl ::core::default::Default for UnionBUnion {
    fn default() -> Self {
        UnionBUnion::Byte(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for UnionBUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionBUnion::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
            UnionBUnion::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for UnionBUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionBUnionReader::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
            UnionBUnionReader::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
        }
    }
}
impl UnionBUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionBUnion::Byte(ref item) => write!(f, "{}", item),
            UnionBUnion::Word(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> UnionBUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionBUnionReader::Byte(ref item) => write!(f, "{}", item),
            UnionBUnionReader::Word(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Byte> for UnionBUnion {
    fn from(item: Byte) -> Self {
        UnionBUnion::Byte(item)
    }
}
impl ::core::convert::From<Word> for UnionBUnion {
    fn from(item: Word) -> Self {
        UnionBUnion::Word(item)
    }
}
impl<'r> ::core::convert::From<ByteReader<'r>> for UnionBUnionReader<'r> {
    fn from(item: ByteReader<'r>) -> Self {
        UnionBUnionReader::Byte(item)
    }
}
impl<'r> ::core::convert::From<WordReader<'r>> for UnionBUnionReader<'r> {
    fn from(item: WordReader<'r>) -> Self {
        UnionBUnionReader::Word(item)
    }
}
impl UnionBUnion {
    pub const NAME: &'static str = "UnionBUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            UnionBUnion::Byte(item) => item.as_bytes(),
            UnionBUnion::Word(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            UnionBUnion::Byte(item) => item.as_slice(),
            UnionBUnion::Word(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionBUnion::Byte(_) => 2,
            UnionBUnion::Word(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionBUnion::Byte(_) => "Byte",
            UnionBUnion::Word(_) => "Word",
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionBUnionReader<'r> {
        match self {
            UnionBUnion::Byte(item) => item.as_reader().into(),
            UnionBUnion::Word(item) => item.as_reader().into(),
        }
    }
}
impl<'r> UnionBUnionReader<'r> {
    pub const NAME: &'r str = "UnionBUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            UnionBUnionReader::Byte(item) => item.as_slice(),
            UnionBUnionReader::Word(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionBUnionReader::Byte(_) => 2,
            UnionBUnionReader::Word(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionBUnionReader::Byte(_) => "Byte",
            UnionBUnionReader::Word(_) => "Word",
        }
    }
}
#[derive(Clone)]
pub struct UnionC(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UnionC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UnionC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UnionC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for UnionC {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UnionC::new_unchecked(v)
    }
}
impl UnionC {
    const DEFAULT_VALUE: [u8; 6] = [0, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionCUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Word::new_unchecked(inner).into(),
            1 => Byte::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionCReader<'r> {
        UnionCReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UnionC {
    type Builder = UnionCBuilder;
    const NAME: &'static str = "UnionC";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UnionC(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionCReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionCReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct UnionCReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UnionCReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UnionCReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UnionCReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> UnionCReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionCUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => WordReader::new_unchecked(inner).into(),
            1 => ByteReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UnionCReader<'r> {
    type Entity = UnionC;
    const NAME: &'static str = "UnionCReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UnionCReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => WordReader::verify(inner_slice, compatible),
            1 => ByteReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UnionCBuilder(pub(crate) UnionCUnion);
impl UnionCBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<UnionCUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for UnionCBuilder {
    type Entity = UnionC;
    const NAME: &'static str = "UnionCBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UnionC::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum UnionCUnion {
    Word(Word),
    Byte(Byte),
}
#[derive(Debug, Clone, Copy)]
pub enum UnionCUnionReader<'r> {
    Word(WordReader<'r>),
    Byte(ByteReader<'r>),
}
impl ::core::default::Default for UnionCUnion {
    fn default() -> Self {
        UnionCUnion::Word(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for UnionCUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionCUnion::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
            UnionCUnion::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for UnionCUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionCUnionReader::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
            UnionCUnionReader::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
        }
    }
}
impl UnionCUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionCUnion::Word(ref item) => write!(f, "{}", item),
            UnionCUnion::Byte(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> UnionCUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionCUnionReader::Word(ref item) => write!(f, "{}", item),
            UnionCUnionReader::Byte(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Word> for UnionCUnion {
    fn from(item: Word) -> Self {
        UnionCUnion::Word(item)
    }
}
impl ::core::convert::From<Byte> for UnionCUnion {
    fn from(item: Byte) -> Self {
        UnionCUnion::Byte(item)
    }
}
impl<'r> ::core::convert::From<WordReader<'r>> for UnionCUnionReader<'r> {
    fn from(item: WordReader<'r>) -> Self {
        UnionCUnionReader::Word(item)
    }
}
impl<'r> ::core::convert::From<ByteReader<'r>> for UnionCUnionReader<'r> {
    fn from(item: ByteReader<'r>) -> Self {
        UnionCUnionReader::Byte(item)
    }
}
impl UnionCUnion {
    pub const NAME: &'static str = "UnionCUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            UnionCUnion::Word(item) => item.as_bytes(),
            UnionCUnion::Byte(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            UnionCUnion::Word(item) => item.as_slice(),
            UnionCUnion::Byte(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionCUnion::Word(_) => 0,
            UnionCUnion::Byte(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionCUnion::Word(_) => "Word",
            UnionCUnion::Byte(_) => "Byte",
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionCUnionReader<'r> {
        match self {
            UnionCUnion::Word(item) => item.as_reader().into(),
            UnionCUnion::Byte(item) => item.as_reader().into(),
        }
    }
}
impl<'r> UnionCUnionReader<'r> {
    pub const NAME: &'r str = "UnionCUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            UnionCUnionReader::Word(item) => item.as_slice(),
            UnionCUnionReader::Byte(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionCUnionReader::Word(_) => 0,
            UnionCUnionReader::Byte(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionCUnionReader::Word(_) => "Word",
            UnionCUnionReader::Byte(_) => "Byte",
        }
    }
}
#[derive(Clone)]
pub struct UnionD(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UnionD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UnionD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UnionD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for UnionD {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UnionD::new_unchecked(v)
    }
}
impl UnionD {
    const DEFAULT_VALUE: [u8; 6] = [2, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionDUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            2 => Word::new_unchecked(inner).into(),
            4 => Byte::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionDReader<'r> {
        UnionDReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UnionD {
    type Builder = UnionDBuilder;
    const NAME: &'static str = "UnionD";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UnionD(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionDReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UnionDReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct UnionDReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UnionDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UnionDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UnionDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> UnionDReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> UnionDUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            2 => WordReader::new_unchecked(inner).into(),
            4 => ByteReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UnionDReader<'r> {
    type Entity = UnionD;
    const NAME: &'static str = "UnionDReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UnionDReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            2 => WordReader::verify(inner_slice, compatible),
            4 => ByteReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct UnionDBuilder(pub(crate) UnionDUnion);
impl UnionDBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<UnionDUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for UnionDBuilder {
    type Entity = UnionD;
    const NAME: &'static str = "UnionDBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UnionD::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum UnionDUnion {
    Word(Word),
    Byte(Byte),
}
#[derive(Debug, Clone, Copy)]
pub enum UnionDUnionReader<'r> {
    Word(WordReader<'r>),
    Byte(ByteReader<'r>),
}
impl ::core::default::Default for UnionDUnion {
    fn default() -> Self {
        UnionDUnion::Word(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for UnionDUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionDUnion::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
            UnionDUnion::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for UnionDUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionDUnionReader::Word(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Word::NAME, item)
            }
            UnionDUnionReader::Byte(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Byte::NAME, item)
            }
        }
    }
}
impl UnionDUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionDUnion::Word(ref item) => write!(f, "{}", item),
            UnionDUnion::Byte(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> UnionDUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            UnionDUnionReader::Word(ref item) => write!(f, "{}", item),
            UnionDUnionReader::Byte(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Word> for UnionDUnion {
    fn from(item: Word) -> Self {
        UnionDUnion::Word(item)
    }
}
impl ::core::convert::From<Byte> for UnionDUnion {
    fn from(item: Byte) -> Self {
        UnionDUnion::Byte(item)
    }
}
impl<'r> ::core::convert::From<WordReader<'r>> for UnionDUnionReader<'r> {
    fn from(item: WordReader<'r>) -> Self {
        UnionDUnionReader::Word(item)
    }
}
impl<'r> ::core::convert::From<ByteReader<'r>> for UnionDUnionReader<'r> {
    fn from(item: ByteReader<'r>) -> Self {
        UnionDUnionReader::Byte(item)
    }
}
impl UnionDUnion {
    pub const NAME: &'static str = "UnionDUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            UnionDUnion::Word(item) => item.as_bytes(),
            UnionDUnion::Byte(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            UnionDUnion::Word(item) => item.as_slice(),
            UnionDUnion::Byte(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionDUnion::Word(_) => 2,
            UnionDUnion::Byte(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionDUnion::Word(_) => "Word",
            UnionDUnion::Byte(_) => "Byte",
        }
    }
    pub fn as_reader<'r>(&'r self) -> UnionDUnionReader<'r> {
        match self {
            UnionDUnion::Word(item) => item.as_reader().into(),
            UnionDUnion::Byte(item) => item.as_reader().into(),
        }
    }
}
impl<'r> UnionDUnionReader<'r> {
    pub const NAME: &'r str = "UnionDUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            UnionDUnionReader::Word(item) => item.as_slice(),
            UnionDUnionReader::Byte(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            UnionDUnionReader::Word(_) => 2,
            UnionDUnionReader::Byte(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            UnionDUnionReader::Word(_) => "Word",
            UnionDUnionReader::Byte(_) => "Byte",
        }
    }
}
#[derive(Clone)]
pub struct TableA(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TableA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TableA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TableA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        write!(f, ", {}: {}", "f6", self.f6())?;
        write!(f, ", {}: {}", "f7", self.f7())?;
        write!(f, ", {}: {}", "f8", self.f8())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TableA {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TableA::new_unchecked(v)
    }
}
impl TableA {
    const DEFAULT_VALUE: [u8; 69] = [
        69, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 46, 0, 0, 0, 50, 0, 0, 0, 54, 0, 0, 0, 63, 0, 0, 0,
        63, 0, 0, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0,
        8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Word2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> StructA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        StructA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f3(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn f4(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BytesVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f5(&self) -> Table1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Table1::new_unchecked(self.0.slice(start..end))
    }
    pub fn f6(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f7(&self) -> UnionA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        UnionA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f8(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TableAReader<'r> {
        TableAReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TableA {
    type Builder = TableABuilder;
    const NAME: &'static str = "TableA";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TableA(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TableAReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TableAReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
            .f5(self.f5())
            .f6(self.f6())
            .f7(self.f7())
            .f8(self.f8())
    }
}
#[derive(Clone, Copy)]
pub struct TableAReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TableAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TableAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TableAReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        write!(f, ", {}: {}", "f6", self.f6())?;
        write!(f, ", {}: {}", "f7", self.f7())?;
        write!(f, ", {}: {}", "f8", self.f8())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TableAReader<'r> {
    pub const FIELD_COUNT: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f1(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Word2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> StructAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        StructAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f3(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f4(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BytesVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f5(&self) -> Table1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Table1Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f6(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f7(&self) -> UnionAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        UnionAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f8(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[36..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TableAReader<'r> {
    type Entity = TableA;
    const NAME: &'static str = "TableAReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TableAReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Word2Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        StructAReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BytesVecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Table1Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesOptReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        UnionAReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        ByteReader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TableABuilder {
    pub(crate) f1: Word2,
    pub(crate) f2: StructA,
    pub(crate) f3: Bytes,
    pub(crate) f4: BytesVec,
    pub(crate) f5: Table1,
    pub(crate) f6: BytesOpt,
    pub(crate) f7: UnionA,
    pub(crate) f8: Byte,
}
impl TableABuilder {
    pub const FIELD_COUNT: usize = 8;
    pub fn f1(mut self, v: Word2) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: StructA) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Bytes) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: BytesVec) -> Self {
        self.f4 = v;
        self
    }
    pub fn f5(mut self, v: Table1) -> Self {
        self.f5 = v;
        self
    }
    pub fn f6(mut self, v: BytesOpt) -> Self {
        self.f6 = v;
        self
    }
    pub fn f7(mut self, v: UnionA) -> Self {
        self.f7 = v;
        self
    }
    pub fn f8(mut self, v: Byte) -> Self {
        self.f8 = v;
        self
    }
}
impl molecule::prelude::Builder for TableABuilder {
    type Entity = TableA;
    const NAME: &'static str = "TableABuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
            + self.f3.as_slice().len()
            + self.f4.as_slice().len()
            + self.f5.as_slice().len()
            + self.f6.as_slice().len()
            + self.f7.as_slice().len()
            + self.f8.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        offsets.push(total_size);
        total_size += self.f3.as_slice().len();
        offsets.push(total_size);
        total_size += self.f4.as_slice().len();
        offsets.push(total_size);
        total_size += self.f5.as_slice().len();
        offsets.push(total_size);
        total_size += self.f6.as_slice().len();
        offsets.push(total_size);
        total_size += self.f7.as_slice().len();
        offsets.push(total_size);
        total_size += self.f8.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        writer.write_all(self.f5.as_slice())?;
        writer.write_all(self.f6.as_slice())?;
        writer.write_all(self.f7.as_slice())?;
        writer.write_all(self.f8.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TableA::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AllInOne(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AllInOne {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AllInOne {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AllInOne {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f0", self.f0())?;
        write!(f, ", {}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        write!(f, ", {}: {}", "f6", self.f6())?;
        write!(f, ", {}: {}", "f7", self.f7())?;
        write!(f, ", {}: {}", "f8", self.f8())?;
        write!(f, ", {}: {}", "f9", self.f9())?;
        write!(f, ", {}: {}", "f10", self.f10())?;
        write!(f, ", {}: {}", "f11", self.f11())?;
        write!(f, ", {}: {}", "f12", self.f12())?;
        write!(f, ", {}: {}", "f13", self.f13())?;
        write!(f, ", {}: {}", "f14", self.f14())?;
        write!(f, ", {}: {}", "f15", self.f15())?;
        write!(f, ", {}: {}", "f16", self.f16())?;
        write!(f, ", {}: {}", "f17", self.f17())?;
        write!(f, ", {}: {}", "f18", self.f18())?;
        write!(f, ", {}: {}", "f19", self.f19())?;
        write!(f, ", {}: {}", "f20", self.f20())?;
        write!(f, ", {}: {}", "f21", self.f21())?;
        write!(f, ", {}: {}", "f22", self.f22())?;
        write!(f, ", {}: {}", "f23", self.f23())?;
        write!(f, ", {}: {}", "f24", self.f24())?;
        write!(f, ", {}: {}", "f25", self.f25())?;
        write!(f, ", {}: {}", "f26", self.f26())?;
        write!(f, ", {}: {}", "f27", self.f27())?;
        write!(f, ", {}: {}", "f28", self.f28())?;
        write!(f, ", {}: {}", "f29", self.f29())?;
        write!(f, ", {}: {}", "f30", self.f30())?;
        write!(f, ", {}: {}", "f31", self.f31())?;
        write!(f, ", {}: {}", "f32", self.f32())?;
        write!(f, ", {}: {}", "f33", self.f33())?;
        write!(f, ", {}: {}", "f34", self.f34())?;
        write!(f, ", {}: {}", "f35", self.f35())?;
        write!(f, ", {}: {}", "f36", self.f36())?;
        write!(f, ", {}: {}", "f37", self.f37())?;
        write!(f, ", {}: {}", "f38", self.f38())?;
        write!(f, ", {}: {}", "f39", self.f39())?;
        write!(f, ", {}: {}", "f40", self.f40())?;
        write!(f, ", {}: {}", "f41", self.f41())?;
        write!(f, ", {}: {}", "f42", self.f42())?;
        write!(f, ", {}: {}", "f43", self.f43())?;
        write!(f, ", {}: {}", "f44", self.f44())?;
        write!(f, ", {}: {}", "f45", self.f45())?;
        write!(f, ", {}: {}", "f46", self.f46())?;
        write!(f, ", {}: {}", "f47", self.f47())?;
        write!(f, ", {}: {}", "f48", self.f48())?;
        write!(f, ", {}: {}", "f49", self.f49())?;
        write!(f, ", {}: {}", "f50", self.f50())?;
        write!(f, ", {}: {}", "f51", self.f51())?;
        write!(f, ", {}: {}", "f52", self.f52())?;
        write!(f, ", {}: {}", "f53", self.f53())?;
        write!(f, ", {}: {}", "f54", self.f54())?;
        write!(f, ", {}: {}", "f55", self.f55())?;
        write!(f, ", {}: {}", "f56", self.f56())?;
        write!(f, ", {}: {}", "f57", self.f57())?;
        write!(f, ", {}: {}", "f58", self.f58())?;
        write!(f, ", {}: {}", "f59", self.f59())?;
        write!(f, ", {}: {}", "f60", self.f60())?;
        write!(f, ", {}: {}", "f61", self.f61())?;
        write!(f, ", {}: {}", "f62", self.f62())?;
        write!(f, ", {}: {}", "f63", self.f63())?;
        write!(f, ", {}: {}", "f64", self.f64())?;
        write!(f, ", {}: {}", "f65", self.f65())?;
        write!(f, ", {}: {}", "f66", self.f66())?;
        write!(f, ", {}: {}", "f67", self.f67())?;
        write!(f, ", {}: {}", "f68", self.f68())?;
        write!(f, ", {}: {}", "f69", self.f69())?;
        write!(f, ", {}: {}", "f70", self.f70())?;
        write!(f, ", {}: {}", "f71", self.f71())?;
        write!(f, ", {}: {}", "f72", self.f72())?;
        write!(f, ", {}: {}", "f73", self.f73())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AllInOne {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AllInOne::new_unchecked(v)
    }
}
impl AllInOne {
    const DEFAULT_VALUE: [u8; 1036] = [
        12, 4, 0, 0, 44, 1, 0, 0, 45, 1, 0, 0, 47, 1, 0, 0, 50, 1, 0, 0, 54, 1, 0, 0, 59, 1, 0, 0,
        65, 1, 0, 0, 72, 1, 0, 0, 80, 1, 0, 0, 89, 1, 0, 0, 99, 1, 0, 0, 110, 1, 0, 0, 122, 1, 0,
        0, 135, 1, 0, 0, 149, 1, 0, 0, 164, 1, 0, 0, 180, 1, 0, 0, 182, 1, 0, 0, 186, 1, 0, 0, 192,
        1, 0, 0, 200, 1, 0, 0, 210, 1, 0, 0, 222, 1, 0, 0, 236, 1, 0, 0, 252, 1, 0, 0, 5, 2, 0, 0,
        20, 2, 0, 0, 41, 2, 0, 0, 68, 2, 0, 0, 74, 2, 0, 0, 81, 2, 0, 0, 89, 2, 0, 0, 98, 2, 0, 0,
        104, 2, 0, 0, 109, 2, 0, 0, 119, 2, 0, 0, 129, 2, 0, 0, 133, 2, 0, 0, 140, 2, 0, 0, 152, 2,
        0, 0, 165, 2, 0, 0, 173, 2, 0, 0, 177, 2, 0, 0, 181, 2, 0, 0, 185, 2, 0, 0, 189, 2, 0, 0,
        193, 2, 0, 0, 197, 2, 0, 0, 201, 2, 0, 0, 205, 2, 0, 0, 209, 2, 0, 0, 213, 2, 0, 0, 222, 2,
        0, 0, 239, 2, 0, 0, 10, 3, 0, 0, 45, 3, 0, 0, 88, 3, 0, 0, 178, 3, 0, 0, 178, 3, 0, 0, 178,
        3, 0, 0, 178, 3, 0, 0, 178, 3, 0, 0, 178, 3, 0, 0, 178, 3, 0, 0, 178, 3, 0, 0, 178, 3, 0,
        0, 178, 3, 0, 0, 178, 3, 0, 0, 178, 3, 0, 0, 182, 3, 0, 0, 186, 3, 0, 0, 190, 3, 0, 0, 194,
        3, 0, 0, 199, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 8, 0, 0, 0, 0, 17, 0, 0, 0, 12, 0, 0, 0,
        13, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 35, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 25, 0, 0, 0, 31, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 24, 0, 0, 0, 25, 0, 0, 0, 29, 0, 0, 0,
        35, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 90, 0,
        0, 0, 28, 0, 0, 0, 29, 0, 0, 0, 33, 0, 0, 0, 39, 0, 0, 0, 43, 0, 0, 0, 47, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 43, 0, 0, 0, 24, 0, 0, 0, 25, 0, 0, 0,
        29, 0, 0, 0, 35, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
        0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 36, 0, 0,
        0, 40, 0, 0, 0, 46, 0, 0, 0, 50, 0, 0, 0, 54, 0, 0, 0, 63, 0, 0, 0, 63, 0, 0, 0, 68, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 74;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f0(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn f1(&self) -> Byte2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f2(&self) -> Byte3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f3(&self) -> Byte4 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte4::new_unchecked(self.0.slice(start..end))
    }
    pub fn f4(&self) -> Byte5 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte5::new_unchecked(self.0.slice(start..end))
    }
    pub fn f5(&self) -> Byte6 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Byte6::new_unchecked(self.0.slice(start..end))
    }
    pub fn f6(&self) -> Byte7 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Byte7::new_unchecked(self.0.slice(start..end))
    }
    pub fn f7(&self) -> Byte8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Byte8::new_unchecked(self.0.slice(start..end))
    }
    pub fn f8(&self) -> Byte9 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Byte9::new_unchecked(self.0.slice(start..end))
    }
    pub fn f9(&self) -> Byte10 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Byte10::new_unchecked(self.0.slice(start..end))
    }
    pub fn f10(&self) -> Byte11 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Byte11::new_unchecked(self.0.slice(start..end))
    }
    pub fn f11(&self) -> Byte12 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Byte12::new_unchecked(self.0.slice(start..end))
    }
    pub fn f12(&self) -> Byte13 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        Byte13::new_unchecked(self.0.slice(start..end))
    }
    pub fn f13(&self) -> Byte14 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        let end = molecule::unpack_number(&slice[60..]) as usize;
        Byte14::new_unchecked(self.0.slice(start..end))
    }
    pub fn f14(&self) -> Byte15 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[60..]) as usize;
        let end = molecule::unpack_number(&slice[64..]) as usize;
        Byte15::new_unchecked(self.0.slice(start..end))
    }
    pub fn f15(&self) -> Byte16 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[64..]) as usize;
        let end = molecule::unpack_number(&slice[68..]) as usize;
        Byte16::new_unchecked(self.0.slice(start..end))
    }
    pub fn f16(&self) -> Word {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[68..]) as usize;
        let end = molecule::unpack_number(&slice[72..]) as usize;
        Word::new_unchecked(self.0.slice(start..end))
    }
    pub fn f17(&self) -> Word2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[72..]) as usize;
        let end = molecule::unpack_number(&slice[76..]) as usize;
        Word2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f18(&self) -> Word3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[76..]) as usize;
        let end = molecule::unpack_number(&slice[80..]) as usize;
        Word3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f19(&self) -> Word4 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[80..]) as usize;
        let end = molecule::unpack_number(&slice[84..]) as usize;
        Word4::new_unchecked(self.0.slice(start..end))
    }
    pub fn f20(&self) -> Word5 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[84..]) as usize;
        let end = molecule::unpack_number(&slice[88..]) as usize;
        Word5::new_unchecked(self.0.slice(start..end))
    }
    pub fn f21(&self) -> Word6 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[88..]) as usize;
        let end = molecule::unpack_number(&slice[92..]) as usize;
        Word6::new_unchecked(self.0.slice(start..end))
    }
    pub fn f22(&self) -> Word7 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[92..]) as usize;
        let end = molecule::unpack_number(&slice[96..]) as usize;
        Word7::new_unchecked(self.0.slice(start..end))
    }
    pub fn f23(&self) -> Word8 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[96..]) as usize;
        let end = molecule::unpack_number(&slice[100..]) as usize;
        Word8::new_unchecked(self.0.slice(start..end))
    }
    pub fn f24(&self) -> Byte3x3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[100..]) as usize;
        let end = molecule::unpack_number(&slice[104..]) as usize;
        Byte3x3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f25(&self) -> Byte5x3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[104..]) as usize;
        let end = molecule::unpack_number(&slice[108..]) as usize;
        Byte5x3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f26(&self) -> Byte7x3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[108..]) as usize;
        let end = molecule::unpack_number(&slice[112..]) as usize;
        Byte7x3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f27(&self) -> Byte9x3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[112..]) as usize;
        let end = molecule::unpack_number(&slice[116..]) as usize;
        Byte9x3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f28(&self) -> StructA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[116..]) as usize;
        let end = molecule::unpack_number(&slice[120..]) as usize;
        StructA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f29(&self) -> StructB {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[120..]) as usize;
        let end = molecule::unpack_number(&slice[124..]) as usize;
        StructB::new_unchecked(self.0.slice(start..end))
    }
    pub fn f30(&self) -> StructC {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[124..]) as usize;
        let end = molecule::unpack_number(&slice[128..]) as usize;
        StructC::new_unchecked(self.0.slice(start..end))
    }
    pub fn f31(&self) -> StructD {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[128..]) as usize;
        let end = molecule::unpack_number(&slice[132..]) as usize;
        StructD::new_unchecked(self.0.slice(start..end))
    }
    pub fn f32(&self) -> StructE {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[132..]) as usize;
        let end = molecule::unpack_number(&slice[136..]) as usize;
        StructE::new_unchecked(self.0.slice(start..end))
    }
    pub fn f33(&self) -> StructF {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[136..]) as usize;
        let end = molecule::unpack_number(&slice[140..]) as usize;
        StructF::new_unchecked(self.0.slice(start..end))
    }
    pub fn f34(&self) -> StructG {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[140..]) as usize;
        let end = molecule::unpack_number(&slice[144..]) as usize;
        StructG::new_unchecked(self.0.slice(start..end))
    }
    pub fn f35(&self) -> StructH {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[144..]) as usize;
        let end = molecule::unpack_number(&slice[148..]) as usize;
        StructH::new_unchecked(self.0.slice(start..end))
    }
    pub fn f36(&self) -> StructI {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[148..]) as usize;
        let end = molecule::unpack_number(&slice[152..]) as usize;
        StructI::new_unchecked(self.0.slice(start..end))
    }
    pub fn f37(&self) -> StructJ {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[152..]) as usize;
        let end = molecule::unpack_number(&slice[156..]) as usize;
        StructJ::new_unchecked(self.0.slice(start..end))
    }
    pub fn f38(&self) -> StructIx3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[156..]) as usize;
        let end = molecule::unpack_number(&slice[160..]) as usize;
        StructIx3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f39(&self) -> StructO {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[160..]) as usize;
        let end = molecule::unpack_number(&slice[164..]) as usize;
        StructO::new_unchecked(self.0.slice(start..end))
    }
    pub fn f40(&self) -> StructP {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[164..]) as usize;
        let end = molecule::unpack_number(&slice[168..]) as usize;
        StructP::new_unchecked(self.0.slice(start..end))
    }
    pub fn f41(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[168..]) as usize;
        let end = molecule::unpack_number(&slice[172..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn f42(&self) -> Words {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[172..]) as usize;
        let end = molecule::unpack_number(&slice[176..]) as usize;
        Words::new_unchecked(self.0.slice(start..end))
    }
    pub fn f43(&self) -> Byte3Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[176..]) as usize;
        let end = molecule::unpack_number(&slice[180..]) as usize;
        Byte3Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f44(&self) -> Byte7Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[180..]) as usize;
        let end = molecule::unpack_number(&slice[184..]) as usize;
        Byte7Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f45(&self) -> StructIVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[184..]) as usize;
        let end = molecule::unpack_number(&slice[188..]) as usize;
        StructIVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f46(&self) -> StructJVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[188..]) as usize;
        let end = molecule::unpack_number(&slice[192..]) as usize;
        StructJVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f47(&self) -> StructPVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[192..]) as usize;
        let end = molecule::unpack_number(&slice[196..]) as usize;
        StructPVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f48(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[196..]) as usize;
        let end = molecule::unpack_number(&slice[200..]) as usize;
        BytesVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f49(&self) -> WordsVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[200..]) as usize;
        let end = molecule::unpack_number(&slice[204..]) as usize;
        WordsVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f50(&self) -> Table0 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[204..]) as usize;
        let end = molecule::unpack_number(&slice[208..]) as usize;
        Table0::new_unchecked(self.0.slice(start..end))
    }
    pub fn f51(&self) -> Table1 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[208..]) as usize;
        let end = molecule::unpack_number(&slice[212..]) as usize;
        Table1::new_unchecked(self.0.slice(start..end))
    }
    pub fn f52(&self) -> Table2 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[212..]) as usize;
        let end = molecule::unpack_number(&slice[216..]) as usize;
        Table2::new_unchecked(self.0.slice(start..end))
    }
    pub fn f53(&self) -> Table3 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[216..]) as usize;
        let end = molecule::unpack_number(&slice[220..]) as usize;
        Table3::new_unchecked(self.0.slice(start..end))
    }
    pub fn f54(&self) -> Table4 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[220..]) as usize;
        let end = molecule::unpack_number(&slice[224..]) as usize;
        Table4::new_unchecked(self.0.slice(start..end))
    }
    pub fn f55(&self) -> Table5 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[224..]) as usize;
        let end = molecule::unpack_number(&slice[228..]) as usize;
        Table5::new_unchecked(self.0.slice(start..end))
    }
    pub fn f56(&self) -> Table6 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[228..]) as usize;
        let end = molecule::unpack_number(&slice[232..]) as usize;
        Table6::new_unchecked(self.0.slice(start..end))
    }
    pub fn f57(&self) -> ByteOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[232..]) as usize;
        let end = molecule::unpack_number(&slice[236..]) as usize;
        ByteOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f58(&self) -> WordOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[236..]) as usize;
        let end = molecule::unpack_number(&slice[240..]) as usize;
        WordOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f59(&self) -> StructAOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[240..]) as usize;
        let end = molecule::unpack_number(&slice[244..]) as usize;
        StructAOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f60(&self) -> StructPOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[244..]) as usize;
        let end = molecule::unpack_number(&slice[248..]) as usize;
        StructPOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f61(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[248..]) as usize;
        let end = molecule::unpack_number(&slice[252..]) as usize;
        BytesOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f62(&self) -> WordsOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[252..]) as usize;
        let end = molecule::unpack_number(&slice[256..]) as usize;
        WordsOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f63(&self) -> BytesVecOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[256..]) as usize;
        let end = molecule::unpack_number(&slice[260..]) as usize;
        BytesVecOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f64(&self) -> WordsVecOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[260..]) as usize;
        let end = molecule::unpack_number(&slice[264..]) as usize;
        WordsVecOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f65(&self) -> Table0Opt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[264..]) as usize;
        let end = molecule::unpack_number(&slice[268..]) as usize;
        Table0Opt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f66(&self) -> Table6Opt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[268..]) as usize;
        let end = molecule::unpack_number(&slice[272..]) as usize;
        Table6Opt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f67(&self) -> Table6OptOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[272..]) as usize;
        let end = molecule::unpack_number(&slice[276..]) as usize;
        Table6OptOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn f68(&self) -> ByteOptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[276..]) as usize;
        let end = molecule::unpack_number(&slice[280..]) as usize;
        ByteOptVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f69(&self) -> WordOptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[280..]) as usize;
        let end = molecule::unpack_number(&slice[284..]) as usize;
        WordOptVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f70(&self) -> WordsOptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[284..]) as usize;
        let end = molecule::unpack_number(&slice[288..]) as usize;
        WordsOptVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f71(&self) -> BytesOptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[288..]) as usize;
        let end = molecule::unpack_number(&slice[292..]) as usize;
        BytesOptVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn f72(&self) -> UnionA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[292..]) as usize;
        let end = molecule::unpack_number(&slice[296..]) as usize;
        UnionA::new_unchecked(self.0.slice(start..end))
    }
    pub fn f73(&self) -> TableA {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[296..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[300..]) as usize;
            TableA::new_unchecked(self.0.slice(start..end))
        } else {
            TableA::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AllInOneReader<'r> {
        AllInOneReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AllInOne {
    type Builder = AllInOneBuilder;
    const NAME: &'static str = "AllInOne";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AllInOne(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AllInOneReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AllInOneReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .f0(self.f0())
            .f1(self.f1())
            .f2(self.f2())
            .f3(self.f3())
            .f4(self.f4())
            .f5(self.f5())
            .f6(self.f6())
            .f7(self.f7())
            .f8(self.f8())
            .f9(self.f9())
            .f10(self.f10())
            .f11(self.f11())
            .f12(self.f12())
            .f13(self.f13())
            .f14(self.f14())
            .f15(self.f15())
            .f16(self.f16())
            .f17(self.f17())
            .f18(self.f18())
            .f19(self.f19())
            .f20(self.f20())
            .f21(self.f21())
            .f22(self.f22())
            .f23(self.f23())
            .f24(self.f24())
            .f25(self.f25())
            .f26(self.f26())
            .f27(self.f27())
            .f28(self.f28())
            .f29(self.f29())
            .f30(self.f30())
            .f31(self.f31())
            .f32(self.f32())
            .f33(self.f33())
            .f34(self.f34())
            .f35(self.f35())
            .f36(self.f36())
            .f37(self.f37())
            .f38(self.f38())
            .f39(self.f39())
            .f40(self.f40())
            .f41(self.f41())
            .f42(self.f42())
            .f43(self.f43())
            .f44(self.f44())
            .f45(self.f45())
            .f46(self.f46())
            .f47(self.f47())
            .f48(self.f48())
            .f49(self.f49())
            .f50(self.f50())
            .f51(self.f51())
            .f52(self.f52())
            .f53(self.f53())
            .f54(self.f54())
            .f55(self.f55())
            .f56(self.f56())
            .f57(self.f57())
            .f58(self.f58())
            .f59(self.f59())
            .f60(self.f60())
            .f61(self.f61())
            .f62(self.f62())
            .f63(self.f63())
            .f64(self.f64())
            .f65(self.f65())
            .f66(self.f66())
            .f67(self.f67())
            .f68(self.f68())
            .f69(self.f69())
            .f70(self.f70())
            .f71(self.f71())
            .f72(self.f72())
            .f73(self.f73())
    }
}
#[derive(Clone, Copy)]
pub struct AllInOneReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AllInOneReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AllInOneReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AllInOneReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "f0", self.f0())?;
        write!(f, ", {}: {}", "f1", self.f1())?;
        write!(f, ", {}: {}", "f2", self.f2())?;
        write!(f, ", {}: {}", "f3", self.f3())?;
        write!(f, ", {}: {}", "f4", self.f4())?;
        write!(f, ", {}: {}", "f5", self.f5())?;
        write!(f, ", {}: {}", "f6", self.f6())?;
        write!(f, ", {}: {}", "f7", self.f7())?;
        write!(f, ", {}: {}", "f8", self.f8())?;
        write!(f, ", {}: {}", "f9", self.f9())?;
        write!(f, ", {}: {}", "f10", self.f10())?;
        write!(f, ", {}: {}", "f11", self.f11())?;
        write!(f, ", {}: {}", "f12", self.f12())?;
        write!(f, ", {}: {}", "f13", self.f13())?;
        write!(f, ", {}: {}", "f14", self.f14())?;
        write!(f, ", {}: {}", "f15", self.f15())?;
        write!(f, ", {}: {}", "f16", self.f16())?;
        write!(f, ", {}: {}", "f17", self.f17())?;
        write!(f, ", {}: {}", "f18", self.f18())?;
        write!(f, ", {}: {}", "f19", self.f19())?;
        write!(f, ", {}: {}", "f20", self.f20())?;
        write!(f, ", {}: {}", "f21", self.f21())?;
        write!(f, ", {}: {}", "f22", self.f22())?;
        write!(f, ", {}: {}", "f23", self.f23())?;
        write!(f, ", {}: {}", "f24", self.f24())?;
        write!(f, ", {}: {}", "f25", self.f25())?;
        write!(f, ", {}: {}", "f26", self.f26())?;
        write!(f, ", {}: {}", "f27", self.f27())?;
        write!(f, ", {}: {}", "f28", self.f28())?;
        write!(f, ", {}: {}", "f29", self.f29())?;
        write!(f, ", {}: {}", "f30", self.f30())?;
        write!(f, ", {}: {}", "f31", self.f31())?;
        write!(f, ", {}: {}", "f32", self.f32())?;
        write!(f, ", {}: {}", "f33", self.f33())?;
        write!(f, ", {}: {}", "f34", self.f34())?;
        write!(f, ", {}: {}", "f35", self.f35())?;
        write!(f, ", {}: {}", "f36", self.f36())?;
        write!(f, ", {}: {}", "f37", self.f37())?;
        write!(f, ", {}: {}", "f38", self.f38())?;
        write!(f, ", {}: {}", "f39", self.f39())?;
        write!(f, ", {}: {}", "f40", self.f40())?;
        write!(f, ", {}: {}", "f41", self.f41())?;
        write!(f, ", {}: {}", "f42", self.f42())?;
        write!(f, ", {}: {}", "f43", self.f43())?;
        write!(f, ", {}: {}", "f44", self.f44())?;
        write!(f, ", {}: {}", "f45", self.f45())?;
        write!(f, ", {}: {}", "f46", self.f46())?;
        write!(f, ", {}: {}", "f47", self.f47())?;
        write!(f, ", {}: {}", "f48", self.f48())?;
        write!(f, ", {}: {}", "f49", self.f49())?;
        write!(f, ", {}: {}", "f50", self.f50())?;
        write!(f, ", {}: {}", "f51", self.f51())?;
        write!(f, ", {}: {}", "f52", self.f52())?;
        write!(f, ", {}: {}", "f53", self.f53())?;
        write!(f, ", {}: {}", "f54", self.f54())?;
        write!(f, ", {}: {}", "f55", self.f55())?;
        write!(f, ", {}: {}", "f56", self.f56())?;
        write!(f, ", {}: {}", "f57", self.f57())?;
        write!(f, ", {}: {}", "f58", self.f58())?;
        write!(f, ", {}: {}", "f59", self.f59())?;
        write!(f, ", {}: {}", "f60", self.f60())?;
        write!(f, ", {}: {}", "f61", self.f61())?;
        write!(f, ", {}: {}", "f62", self.f62())?;
        write!(f, ", {}: {}", "f63", self.f63())?;
        write!(f, ", {}: {}", "f64", self.f64())?;
        write!(f, ", {}: {}", "f65", self.f65())?;
        write!(f, ", {}: {}", "f66", self.f66())?;
        write!(f, ", {}: {}", "f67", self.f67())?;
        write!(f, ", {}: {}", "f68", self.f68())?;
        write!(f, ", {}: {}", "f69", self.f69())?;
        write!(f, ", {}: {}", "f70", self.f70())?;
        write!(f, ", {}: {}", "f71", self.f71())?;
        write!(f, ", {}: {}", "f72", self.f72())?;
        write!(f, ", {}: {}", "f73", self.f73())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AllInOneReader<'r> {
    pub const FIELD_COUNT: usize = 74;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn f0(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f1(&self) -> Byte2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f2(&self) -> Byte3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f3(&self) -> Byte4Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte4Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f4(&self) -> Byte5Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte5Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f5(&self) -> Byte6Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Byte6Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f6(&self) -> Byte7Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        let end = molecule::unpack_number(&slice[32..]) as usize;
        Byte7Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f7(&self) -> Byte8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[32..]) as usize;
        let end = molecule::unpack_number(&slice[36..]) as usize;
        Byte8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f8(&self) -> Byte9Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[36..]) as usize;
        let end = molecule::unpack_number(&slice[40..]) as usize;
        Byte9Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f9(&self) -> Byte10Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[40..]) as usize;
        let end = molecule::unpack_number(&slice[44..]) as usize;
        Byte10Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f10(&self) -> Byte11Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[44..]) as usize;
        let end = molecule::unpack_number(&slice[48..]) as usize;
        Byte11Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f11(&self) -> Byte12Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[48..]) as usize;
        let end = molecule::unpack_number(&slice[52..]) as usize;
        Byte12Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f12(&self) -> Byte13Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[52..]) as usize;
        let end = molecule::unpack_number(&slice[56..]) as usize;
        Byte13Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f13(&self) -> Byte14Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[56..]) as usize;
        let end = molecule::unpack_number(&slice[60..]) as usize;
        Byte14Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f14(&self) -> Byte15Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[60..]) as usize;
        let end = molecule::unpack_number(&slice[64..]) as usize;
        Byte15Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f15(&self) -> Byte16Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[64..]) as usize;
        let end = molecule::unpack_number(&slice[68..]) as usize;
        Byte16Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f16(&self) -> WordReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[68..]) as usize;
        let end = molecule::unpack_number(&slice[72..]) as usize;
        WordReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f17(&self) -> Word2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[72..]) as usize;
        let end = molecule::unpack_number(&slice[76..]) as usize;
        Word2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f18(&self) -> Word3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[76..]) as usize;
        let end = molecule::unpack_number(&slice[80..]) as usize;
        Word3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f19(&self) -> Word4Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[80..]) as usize;
        let end = molecule::unpack_number(&slice[84..]) as usize;
        Word4Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f20(&self) -> Word5Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[84..]) as usize;
        let end = molecule::unpack_number(&slice[88..]) as usize;
        Word5Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f21(&self) -> Word6Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[88..]) as usize;
        let end = molecule::unpack_number(&slice[92..]) as usize;
        Word6Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f22(&self) -> Word7Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[92..]) as usize;
        let end = molecule::unpack_number(&slice[96..]) as usize;
        Word7Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f23(&self) -> Word8Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[96..]) as usize;
        let end = molecule::unpack_number(&slice[100..]) as usize;
        Word8Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f24(&self) -> Byte3x3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[100..]) as usize;
        let end = molecule::unpack_number(&slice[104..]) as usize;
        Byte3x3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f25(&self) -> Byte5x3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[104..]) as usize;
        let end = molecule::unpack_number(&slice[108..]) as usize;
        Byte5x3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f26(&self) -> Byte7x3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[108..]) as usize;
        let end = molecule::unpack_number(&slice[112..]) as usize;
        Byte7x3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f27(&self) -> Byte9x3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[112..]) as usize;
        let end = molecule::unpack_number(&slice[116..]) as usize;
        Byte9x3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f28(&self) -> StructAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[116..]) as usize;
        let end = molecule::unpack_number(&slice[120..]) as usize;
        StructAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f29(&self) -> StructBReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[120..]) as usize;
        let end = molecule::unpack_number(&slice[124..]) as usize;
        StructBReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f30(&self) -> StructCReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[124..]) as usize;
        let end = molecule::unpack_number(&slice[128..]) as usize;
        StructCReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f31(&self) -> StructDReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[128..]) as usize;
        let end = molecule::unpack_number(&slice[132..]) as usize;
        StructDReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f32(&self) -> StructEReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[132..]) as usize;
        let end = molecule::unpack_number(&slice[136..]) as usize;
        StructEReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f33(&self) -> StructFReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[136..]) as usize;
        let end = molecule::unpack_number(&slice[140..]) as usize;
        StructFReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f34(&self) -> StructGReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[140..]) as usize;
        let end = molecule::unpack_number(&slice[144..]) as usize;
        StructGReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f35(&self) -> StructHReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[144..]) as usize;
        let end = molecule::unpack_number(&slice[148..]) as usize;
        StructHReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f36(&self) -> StructIReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[148..]) as usize;
        let end = molecule::unpack_number(&slice[152..]) as usize;
        StructIReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f37(&self) -> StructJReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[152..]) as usize;
        let end = molecule::unpack_number(&slice[156..]) as usize;
        StructJReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f38(&self) -> StructIx3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[156..]) as usize;
        let end = molecule::unpack_number(&slice[160..]) as usize;
        StructIx3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f39(&self) -> StructOReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[160..]) as usize;
        let end = molecule::unpack_number(&slice[164..]) as usize;
        StructOReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f40(&self) -> StructPReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[164..]) as usize;
        let end = molecule::unpack_number(&slice[168..]) as usize;
        StructPReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f41(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[168..]) as usize;
        let end = molecule::unpack_number(&slice[172..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f42(&self) -> WordsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[172..]) as usize;
        let end = molecule::unpack_number(&slice[176..]) as usize;
        WordsReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f43(&self) -> Byte3VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[176..]) as usize;
        let end = molecule::unpack_number(&slice[180..]) as usize;
        Byte3VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f44(&self) -> Byte7VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[180..]) as usize;
        let end = molecule::unpack_number(&slice[184..]) as usize;
        Byte7VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f45(&self) -> StructIVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[184..]) as usize;
        let end = molecule::unpack_number(&slice[188..]) as usize;
        StructIVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f46(&self) -> StructJVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[188..]) as usize;
        let end = molecule::unpack_number(&slice[192..]) as usize;
        StructJVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f47(&self) -> StructPVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[192..]) as usize;
        let end = molecule::unpack_number(&slice[196..]) as usize;
        StructPVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f48(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[196..]) as usize;
        let end = molecule::unpack_number(&slice[200..]) as usize;
        BytesVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f49(&self) -> WordsVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[200..]) as usize;
        let end = molecule::unpack_number(&slice[204..]) as usize;
        WordsVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f50(&self) -> Table0Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[204..]) as usize;
        let end = molecule::unpack_number(&slice[208..]) as usize;
        Table0Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f51(&self) -> Table1Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[208..]) as usize;
        let end = molecule::unpack_number(&slice[212..]) as usize;
        Table1Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f52(&self) -> Table2Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[212..]) as usize;
        let end = molecule::unpack_number(&slice[216..]) as usize;
        Table2Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f53(&self) -> Table3Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[216..]) as usize;
        let end = molecule::unpack_number(&slice[220..]) as usize;
        Table3Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f54(&self) -> Table4Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[220..]) as usize;
        let end = molecule::unpack_number(&slice[224..]) as usize;
        Table4Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f55(&self) -> Table5Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[224..]) as usize;
        let end = molecule::unpack_number(&slice[228..]) as usize;
        Table5Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f56(&self) -> Table6Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[228..]) as usize;
        let end = molecule::unpack_number(&slice[232..]) as usize;
        Table6Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f57(&self) -> ByteOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[232..]) as usize;
        let end = molecule::unpack_number(&slice[236..]) as usize;
        ByteOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f58(&self) -> WordOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[236..]) as usize;
        let end = molecule::unpack_number(&slice[240..]) as usize;
        WordOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f59(&self) -> StructAOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[240..]) as usize;
        let end = molecule::unpack_number(&slice[244..]) as usize;
        StructAOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f60(&self) -> StructPOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[244..]) as usize;
        let end = molecule::unpack_number(&slice[248..]) as usize;
        StructPOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f61(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[248..]) as usize;
        let end = molecule::unpack_number(&slice[252..]) as usize;
        BytesOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f62(&self) -> WordsOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[252..]) as usize;
        let end = molecule::unpack_number(&slice[256..]) as usize;
        WordsOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f63(&self) -> BytesVecOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[256..]) as usize;
        let end = molecule::unpack_number(&slice[260..]) as usize;
        BytesVecOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f64(&self) -> WordsVecOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[260..]) as usize;
        let end = molecule::unpack_number(&slice[264..]) as usize;
        WordsVecOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f65(&self) -> Table0OptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[264..]) as usize;
        let end = molecule::unpack_number(&slice[268..]) as usize;
        Table0OptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f66(&self) -> Table6OptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[268..]) as usize;
        let end = molecule::unpack_number(&slice[272..]) as usize;
        Table6OptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f67(&self) -> Table6OptOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[272..]) as usize;
        let end = molecule::unpack_number(&slice[276..]) as usize;
        Table6OptOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f68(&self) -> ByteOptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[276..]) as usize;
        let end = molecule::unpack_number(&slice[280..]) as usize;
        ByteOptVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f69(&self) -> WordOptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[280..]) as usize;
        let end = molecule::unpack_number(&slice[284..]) as usize;
        WordOptVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f70(&self) -> WordsOptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[284..]) as usize;
        let end = molecule::unpack_number(&slice[288..]) as usize;
        WordsOptVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f71(&self) -> BytesOptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[288..]) as usize;
        let end = molecule::unpack_number(&slice[292..]) as usize;
        BytesOptVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f72(&self) -> UnionAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[292..]) as usize;
        let end = molecule::unpack_number(&slice[296..]) as usize;
        UnionAReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn f73(&self) -> TableAReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[296..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[300..]) as usize;
            TableAReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TableAReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AllInOneReader<'r> {
    type Entity = AllInOne;
    const NAME: &'static str = "AllInOneReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AllInOneReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte2Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte3Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte4Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte5Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Byte6Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Byte7Reader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Byte8Reader::verify(&slice[offsets[7]..offsets[8]], compatible)?;
        Byte9Reader::verify(&slice[offsets[8]..offsets[9]], compatible)?;
        Byte10Reader::verify(&slice[offsets[9]..offsets[10]], compatible)?;
        Byte11Reader::verify(&slice[offsets[10]..offsets[11]], compatible)?;
        Byte12Reader::verify(&slice[offsets[11]..offsets[12]], compatible)?;
        Byte13Reader::verify(&slice[offsets[12]..offsets[13]], compatible)?;
        Byte14Reader::verify(&slice[offsets[13]..offsets[14]], compatible)?;
        Byte15Reader::verify(&slice[offsets[14]..offsets[15]], compatible)?;
        Byte16Reader::verify(&slice[offsets[15]..offsets[16]], compatible)?;
        WordReader::verify(&slice[offsets[16]..offsets[17]], compatible)?;
        Word2Reader::verify(&slice[offsets[17]..offsets[18]], compatible)?;
        Word3Reader::verify(&slice[offsets[18]..offsets[19]], compatible)?;
        Word4Reader::verify(&slice[offsets[19]..offsets[20]], compatible)?;
        Word5Reader::verify(&slice[offsets[20]..offsets[21]], compatible)?;
        Word6Reader::verify(&slice[offsets[21]..offsets[22]], compatible)?;
        Word7Reader::verify(&slice[offsets[22]..offsets[23]], compatible)?;
        Word8Reader::verify(&slice[offsets[23]..offsets[24]], compatible)?;
        Byte3x3Reader::verify(&slice[offsets[24]..offsets[25]], compatible)?;
        Byte5x3Reader::verify(&slice[offsets[25]..offsets[26]], compatible)?;
        Byte7x3Reader::verify(&slice[offsets[26]..offsets[27]], compatible)?;
        Byte9x3Reader::verify(&slice[offsets[27]..offsets[28]], compatible)?;
        StructAReader::verify(&slice[offsets[28]..offsets[29]], compatible)?;
        StructBReader::verify(&slice[offsets[29]..offsets[30]], compatible)?;
        StructCReader::verify(&slice[offsets[30]..offsets[31]], compatible)?;
        StructDReader::verify(&slice[offsets[31]..offsets[32]], compatible)?;
        StructEReader::verify(&slice[offsets[32]..offsets[33]], compatible)?;
        StructFReader::verify(&slice[offsets[33]..offsets[34]], compatible)?;
        StructGReader::verify(&slice[offsets[34]..offsets[35]], compatible)?;
        StructHReader::verify(&slice[offsets[35]..offsets[36]], compatible)?;
        StructIReader::verify(&slice[offsets[36]..offsets[37]], compatible)?;
        StructJReader::verify(&slice[offsets[37]..offsets[38]], compatible)?;
        StructIx3Reader::verify(&slice[offsets[38]..offsets[39]], compatible)?;
        StructOReader::verify(&slice[offsets[39]..offsets[40]], compatible)?;
        StructPReader::verify(&slice[offsets[40]..offsets[41]], compatible)?;
        BytesReader::verify(&slice[offsets[41]..offsets[42]], compatible)?;
        WordsReader::verify(&slice[offsets[42]..offsets[43]], compatible)?;
        Byte3VecReader::verify(&slice[offsets[43]..offsets[44]], compatible)?;
        Byte7VecReader::verify(&slice[offsets[44]..offsets[45]], compatible)?;
        StructIVecReader::verify(&slice[offsets[45]..offsets[46]], compatible)?;
        StructJVecReader::verify(&slice[offsets[46]..offsets[47]], compatible)?;
        StructPVecReader::verify(&slice[offsets[47]..offsets[48]], compatible)?;
        BytesVecReader::verify(&slice[offsets[48]..offsets[49]], compatible)?;
        WordsVecReader::verify(&slice[offsets[49]..offsets[50]], compatible)?;
        Table0Reader::verify(&slice[offsets[50]..offsets[51]], compatible)?;
        Table1Reader::verify(&slice[offsets[51]..offsets[52]], compatible)?;
        Table2Reader::verify(&slice[offsets[52]..offsets[53]], compatible)?;
        Table3Reader::verify(&slice[offsets[53]..offsets[54]], compatible)?;
        Table4Reader::verify(&slice[offsets[54]..offsets[55]], compatible)?;
        Table5Reader::verify(&slice[offsets[55]..offsets[56]], compatible)?;
        Table6Reader::verify(&slice[offsets[56]..offsets[57]], compatible)?;
        ByteOptReader::verify(&slice[offsets[57]..offsets[58]], compatible)?;
        WordOptReader::verify(&slice[offsets[58]..offsets[59]], compatible)?;
        StructAOptReader::verify(&slice[offsets[59]..offsets[60]], compatible)?;
        StructPOptReader::verify(&slice[offsets[60]..offsets[61]], compatible)?;
        BytesOptReader::verify(&slice[offsets[61]..offsets[62]], compatible)?;
        WordsOptReader::verify(&slice[offsets[62]..offsets[63]], compatible)?;
        BytesVecOptReader::verify(&slice[offsets[63]..offsets[64]], compatible)?;
        WordsVecOptReader::verify(&slice[offsets[64]..offsets[65]], compatible)?;
        Table0OptReader::verify(&slice[offsets[65]..offsets[66]], compatible)?;
        Table6OptReader::verify(&slice[offsets[66]..offsets[67]], compatible)?;
        Table6OptOptReader::verify(&slice[offsets[67]..offsets[68]], compatible)?;
        ByteOptVecReader::verify(&slice[offsets[68]..offsets[69]], compatible)?;
        WordOptVecReader::verify(&slice[offsets[69]..offsets[70]], compatible)?;
        WordsOptVecReader::verify(&slice[offsets[70]..offsets[71]], compatible)?;
        BytesOptVecReader::verify(&slice[offsets[71]..offsets[72]], compatible)?;
        UnionAReader::verify(&slice[offsets[72]..offsets[73]], compatible)?;
        TableAReader::verify(&slice[offsets[73]..offsets[74]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct AllInOneBuilder {
    pub(crate) f0: Byte,
    pub(crate) f1: Byte2,
    pub(crate) f2: Byte3,
    pub(crate) f3: Byte4,
    pub(crate) f4: Byte5,
    pub(crate) f5: Byte6,
    pub(crate) f6: Byte7,
    pub(crate) f7: Byte8,
    pub(crate) f8: Byte9,
    pub(crate) f9: Byte10,
    pub(crate) f10: Byte11,
    pub(crate) f11: Byte12,
    pub(crate) f12: Byte13,
    pub(crate) f13: Byte14,
    pub(crate) f14: Byte15,
    pub(crate) f15: Byte16,
    pub(crate) f16: Word,
    pub(crate) f17: Word2,
    pub(crate) f18: Word3,
    pub(crate) f19: Word4,
    pub(crate) f20: Word5,
    pub(crate) f21: Word6,
    pub(crate) f22: Word7,
    pub(crate) f23: Word8,
    pub(crate) f24: Byte3x3,
    pub(crate) f25: Byte5x3,
    pub(crate) f26: Byte7x3,
    pub(crate) f27: Byte9x3,
    pub(crate) f28: StructA,
    pub(crate) f29: StructB,
    pub(crate) f30: StructC,
    pub(crate) f31: StructD,
    pub(crate) f32: StructE,
    pub(crate) f33: StructF,
    pub(crate) f34: StructG,
    pub(crate) f35: StructH,
    pub(crate) f36: StructI,
    pub(crate) f37: StructJ,
    pub(crate) f38: StructIx3,
    pub(crate) f39: StructO,
    pub(crate) f40: StructP,
    pub(crate) f41: Bytes,
    pub(crate) f42: Words,
    pub(crate) f43: Byte3Vec,
    pub(crate) f44: Byte7Vec,
    pub(crate) f45: StructIVec,
    pub(crate) f46: StructJVec,
    pub(crate) f47: StructPVec,
    pub(crate) f48: BytesVec,
    pub(crate) f49: WordsVec,
    pub(crate) f50: Table0,
    pub(crate) f51: Table1,
    pub(crate) f52: Table2,
    pub(crate) f53: Table3,
    pub(crate) f54: Table4,
    pub(crate) f55: Table5,
    pub(crate) f56: Table6,
    pub(crate) f57: ByteOpt,
    pub(crate) f58: WordOpt,
    pub(crate) f59: StructAOpt,
    pub(crate) f60: StructPOpt,
    pub(crate) f61: BytesOpt,
    pub(crate) f62: WordsOpt,
    pub(crate) f63: BytesVecOpt,
    pub(crate) f64: WordsVecOpt,
    pub(crate) f65: Table0Opt,
    pub(crate) f66: Table6Opt,
    pub(crate) f67: Table6OptOpt,
    pub(crate) f68: ByteOptVec,
    pub(crate) f69: WordOptVec,
    pub(crate) f70: WordsOptVec,
    pub(crate) f71: BytesOptVec,
    pub(crate) f72: UnionA,
    pub(crate) f73: TableA,
}
impl AllInOneBuilder {
    pub const FIELD_COUNT: usize = 74;
    pub fn f0(mut self, v: Byte) -> Self {
        self.f0 = v;
        self
    }
    pub fn f1(mut self, v: Byte2) -> Self {
        self.f1 = v;
        self
    }
    pub fn f2(mut self, v: Byte3) -> Self {
        self.f2 = v;
        self
    }
    pub fn f3(mut self, v: Byte4) -> Self {
        self.f3 = v;
        self
    }
    pub fn f4(mut self, v: Byte5) -> Self {
        self.f4 = v;
        self
    }
    pub fn f5(mut self, v: Byte6) -> Self {
        self.f5 = v;
        self
    }
    pub fn f6(mut self, v: Byte7) -> Self {
        self.f6 = v;
        self
    }
    pub fn f7(mut self, v: Byte8) -> Self {
        self.f7 = v;
        self
    }
    pub fn f8(mut self, v: Byte9) -> Self {
        self.f8 = v;
        self
    }
    pub fn f9(mut self, v: Byte10) -> Self {
        self.f9 = v;
        self
    }
    pub fn f10(mut self, v: Byte11) -> Self {
        self.f10 = v;
        self
    }
    pub fn f11(mut self, v: Byte12) -> Self {
        self.f11 = v;
        self
    }
    pub fn f12(mut self, v: Byte13) -> Self {
        self.f12 = v;
        self
    }
    pub fn f13(mut self, v: Byte14) -> Self {
        self.f13 = v;
        self
    }
    pub fn f14(mut self, v: Byte15) -> Self {
        self.f14 = v;
        self
    }
    pub fn f15(mut self, v: Byte16) -> Self {
        self.f15 = v;
        self
    }
    pub fn f16(mut self, v: Word) -> Self {
        self.f16 = v;
        self
    }
    pub fn f17(mut self, v: Word2) -> Self {
        self.f17 = v;
        self
    }
    pub fn f18(mut self, v: Word3) -> Self {
        self.f18 = v;
        self
    }
    pub fn f19(mut self, v: Word4) -> Self {
        self.f19 = v;
        self
    }
    pub fn f20(mut self, v: Word5) -> Self {
        self.f20 = v;
        self
    }
    pub fn f21(mut self, v: Word6) -> Self {
        self.f21 = v;
        self
    }
    pub fn f22(mut self, v: Word7) -> Self {
        self.f22 = v;
        self
    }
    pub fn f23(mut self, v: Word8) -> Self {
        self.f23 = v;
        self
    }
    pub fn f24(mut self, v: Byte3x3) -> Self {
        self.f24 = v;
        self
    }
    pub fn f25(mut self, v: Byte5x3) -> Self {
        self.f25 = v;
        self
    }
    pub fn f26(mut self, v: Byte7x3) -> Self {
        self.f26 = v;
        self
    }
    pub fn f27(mut self, v: Byte9x3) -> Self {
        self.f27 = v;
        self
    }
    pub fn f28(mut self, v: StructA) -> Self {
        self.f28 = v;
        self
    }
    pub fn f29(mut self, v: StructB) -> Self {
        self.f29 = v;
        self
    }
    pub fn f30(mut self, v: StructC) -> Self {
        self.f30 = v;
        self
    }
    pub fn f31(mut self, v: StructD) -> Self {
        self.f31 = v;
        self
    }
    pub fn f32(mut self, v: StructE) -> Self {
        self.f32 = v;
        self
    }
    pub fn f33(mut self, v: StructF) -> Self {
        self.f33 = v;
        self
    }
    pub fn f34(mut self, v: StructG) -> Self {
        self.f34 = v;
        self
    }
    pub fn f35(mut self, v: StructH) -> Self {
        self.f35 = v;
        self
    }
    pub fn f36(mut self, v: StructI) -> Self {
        self.f36 = v;
        self
    }
    pub fn f37(mut self, v: StructJ) -> Self {
        self.f37 = v;
        self
    }
    pub fn f38(mut self, v: StructIx3) -> Self {
        self.f38 = v;
        self
    }
    pub fn f39(mut self, v: StructO) -> Self {
        self.f39 = v;
        self
    }
    pub fn f40(mut self, v: StructP) -> Self {
        self.f40 = v;
        self
    }
    pub fn f41(mut self, v: Bytes) -> Self {
        self.f41 = v;
        self
    }
    pub fn f42(mut self, v: Words) -> Self {
        self.f42 = v;
        self
    }
    pub fn f43(mut self, v: Byte3Vec) -> Self {
        self.f43 = v;
        self
    }
    pub fn f44(mut self, v: Byte7Vec) -> Self {
        self.f44 = v;
        self
    }
    pub fn f45(mut self, v: StructIVec) -> Self {
        self.f45 = v;
        self
    }
    pub fn f46(mut self, v: StructJVec) -> Self {
        self.f46 = v;
        self
    }
    pub fn f47(mut self, v: StructPVec) -> Self {
        self.f47 = v;
        self
    }
    pub fn f48(mut self, v: BytesVec) -> Self {
        self.f48 = v;
        self
    }
    pub fn f49(mut self, v: WordsVec) -> Self {
        self.f49 = v;
        self
    }
    pub fn f50(mut self, v: Table0) -> Self {
        self.f50 = v;
        self
    }
    pub fn f51(mut self, v: Table1) -> Self {
        self.f51 = v;
        self
    }
    pub fn f52(mut self, v: Table2) -> Self {
        self.f52 = v;
        self
    }
    pub fn f53(mut self, v: Table3) -> Self {
        self.f53 = v;
        self
    }
    pub fn f54(mut self, v: Table4) -> Self {
        self.f54 = v;
        self
    }
    pub fn f55(mut self, v: Table5) -> Self {
        self.f55 = v;
        self
    }
    pub fn f56(mut self, v: Table6) -> Self {
        self.f56 = v;
        self
    }
    pub fn f57(mut self, v: ByteOpt) -> Self {
        self.f57 = v;
        self
    }
    pub fn f58(mut self, v: WordOpt) -> Self {
        self.f58 = v;
        self
    }
    pub fn f59(mut self, v: StructAOpt) -> Self {
        self.f59 = v;
        self
    }
    pub fn f60(mut self, v: StructPOpt) -> Self {
        self.f60 = v;
        self
    }
    pub fn f61(mut self, v: BytesOpt) -> Self {
        self.f61 = v;
        self
    }
    pub fn f62(mut self, v: WordsOpt) -> Self {
        self.f62 = v;
        self
    }
    pub fn f63(mut self, v: BytesVecOpt) -> Self {
        self.f63 = v;
        self
    }
    pub fn f64(mut self, v: WordsVecOpt) -> Self {
        self.f64 = v;
        self
    }
    pub fn f65(mut self, v: Table0Opt) -> Self {
        self.f65 = v;
        self
    }
    pub fn f66(mut self, v: Table6Opt) -> Self {
        self.f66 = v;
        self
    }
    pub fn f67(mut self, v: Table6OptOpt) -> Self {
        self.f67 = v;
        self
    }
    pub fn f68(mut self, v: ByteOptVec) -> Self {
        self.f68 = v;
        self
    }
    pub fn f69(mut self, v: WordOptVec) -> Self {
        self.f69 = v;
        self
    }
    pub fn f70(mut self, v: WordsOptVec) -> Self {
        self.f70 = v;
        self
    }
    pub fn f71(mut self, v: BytesOptVec) -> Self {
        self.f71 = v;
        self
    }
    pub fn f72(mut self, v: UnionA) -> Self {
        self.f72 = v;
        self
    }
    pub fn f73(mut self, v: TableA) -> Self {
        self.f73 = v;
        self
    }
}
impl molecule::prelude::Builder for AllInOneBuilder {
    type Entity = AllInOne;
    const NAME: &'static str = "AllInOneBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.f0.as_slice().len()
            + self.f1.as_slice().len()
            + self.f2.as_slice().len()
            + self.f3.as_slice().len()
            + self.f4.as_slice().len()
            + self.f5.as_slice().len()
            + self.f6.as_slice().len()
            + self.f7.as_slice().len()
            + self.f8.as_slice().len()
            + self.f9.as_slice().len()
            + self.f10.as_slice().len()
            + self.f11.as_slice().len()
            + self.f12.as_slice().len()
            + self.f13.as_slice().len()
            + self.f14.as_slice().len()
            + self.f15.as_slice().len()
            + self.f16.as_slice().len()
            + self.f17.as_slice().len()
            + self.f18.as_slice().len()
            + self.f19.as_slice().len()
            + self.f20.as_slice().len()
            + self.f21.as_slice().len()
            + self.f22.as_slice().len()
            + self.f23.as_slice().len()
            + self.f24.as_slice().len()
            + self.f25.as_slice().len()
            + self.f26.as_slice().len()
            + self.f27.as_slice().len()
            + self.f28.as_slice().len()
            + self.f29.as_slice().len()
            + self.f30.as_slice().len()
            + self.f31.as_slice().len()
            + self.f32.as_slice().len()
            + self.f33.as_slice().len()
            + self.f34.as_slice().len()
            + self.f35.as_slice().len()
            + self.f36.as_slice().len()
            + self.f37.as_slice().len()
            + self.f38.as_slice().len()
            + self.f39.as_slice().len()
            + self.f40.as_slice().len()
            + self.f41.as_slice().len()
            + self.f42.as_slice().len()
            + self.f43.as_slice().len()
            + self.f44.as_slice().len()
            + self.f45.as_slice().len()
            + self.f46.as_slice().len()
            + self.f47.as_slice().len()
            + self.f48.as_slice().len()
            + self.f49.as_slice().len()
            + self.f50.as_slice().len()
            + self.f51.as_slice().len()
            + self.f52.as_slice().len()
            + self.f53.as_slice().len()
            + self.f54.as_slice().len()
            + self.f55.as_slice().len()
            + self.f56.as_slice().len()
            + self.f57.as_slice().len()
            + self.f58.as_slice().len()
            + self.f59.as_slice().len()
            + self.f60.as_slice().len()
            + self.f61.as_slice().len()
            + self.f62.as_slice().len()
            + self.f63.as_slice().len()
            + self.f64.as_slice().len()
            + self.f65.as_slice().len()
            + self.f66.as_slice().len()
            + self.f67.as_slice().len()
            + self.f68.as_slice().len()
            + self.f69.as_slice().len()
            + self.f70.as_slice().len()
            + self.f71.as_slice().len()
            + self.f72.as_slice().len()
            + self.f73.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.f0.as_slice().len();
        offsets.push(total_size);
        total_size += self.f1.as_slice().len();
        offsets.push(total_size);
        total_size += self.f2.as_slice().len();
        offsets.push(total_size);
        total_size += self.f3.as_slice().len();
        offsets.push(total_size);
        total_size += self.f4.as_slice().len();
        offsets.push(total_size);
        total_size += self.f5.as_slice().len();
        offsets.push(total_size);
        total_size += self.f6.as_slice().len();
        offsets.push(total_size);
        total_size += self.f7.as_slice().len();
        offsets.push(total_size);
        total_size += self.f8.as_slice().len();
        offsets.push(total_size);
        total_size += self.f9.as_slice().len();
        offsets.push(total_size);
        total_size += self.f10.as_slice().len();
        offsets.push(total_size);
        total_size += self.f11.as_slice().len();
        offsets.push(total_size);
        total_size += self.f12.as_slice().len();
        offsets.push(total_size);
        total_size += self.f13.as_slice().len();
        offsets.push(total_size);
        total_size += self.f14.as_slice().len();
        offsets.push(total_size);
        total_size += self.f15.as_slice().len();
        offsets.push(total_size);
        total_size += self.f16.as_slice().len();
        offsets.push(total_size);
        total_size += self.f17.as_slice().len();
        offsets.push(total_size);
        total_size += self.f18.as_slice().len();
        offsets.push(total_size);
        total_size += self.f19.as_slice().len();
        offsets.push(total_size);
        total_size += self.f20.as_slice().len();
        offsets.push(total_size);
        total_size += self.f21.as_slice().len();
        offsets.push(total_size);
        total_size += self.f22.as_slice().len();
        offsets.push(total_size);
        total_size += self.f23.as_slice().len();
        offsets.push(total_size);
        total_size += self.f24.as_slice().len();
        offsets.push(total_size);
        total_size += self.f25.as_slice().len();
        offsets.push(total_size);
        total_size += self.f26.as_slice().len();
        offsets.push(total_size);
        total_size += self.f27.as_slice().len();
        offsets.push(total_size);
        total_size += self.f28.as_slice().len();
        offsets.push(total_size);
        total_size += self.f29.as_slice().len();
        offsets.push(total_size);
        total_size += self.f30.as_slice().len();
        offsets.push(total_size);
        total_size += self.f31.as_slice().len();
        offsets.push(total_size);
        total_size += self.f32.as_slice().len();
        offsets.push(total_size);
        total_size += self.f33.as_slice().len();
        offsets.push(total_size);
        total_size += self.f34.as_slice().len();
        offsets.push(total_size);
        total_size += self.f35.as_slice().len();
        offsets.push(total_size);
        total_size += self.f36.as_slice().len();
        offsets.push(total_size);
        total_size += self.f37.as_slice().len();
        offsets.push(total_size);
        total_size += self.f38.as_slice().len();
        offsets.push(total_size);
        total_size += self.f39.as_slice().len();
        offsets.push(total_size);
        total_size += self.f40.as_slice().len();
        offsets.push(total_size);
        total_size += self.f41.as_slice().len();
        offsets.push(total_size);
        total_size += self.f42.as_slice().len();
        offsets.push(total_size);
        total_size += self.f43.as_slice().len();
        offsets.push(total_size);
        total_size += self.f44.as_slice().len();
        offsets.push(total_size);
        total_size += self.f45.as_slice().len();
        offsets.push(total_size);
        total_size += self.f46.as_slice().len();
        offsets.push(total_size);
        total_size += self.f47.as_slice().len();
        offsets.push(total_size);
        total_size += self.f48.as_slice().len();
        offsets.push(total_size);
        total_size += self.f49.as_slice().len();
        offsets.push(total_size);
        total_size += self.f50.as_slice().len();
        offsets.push(total_size);
        total_size += self.f51.as_slice().len();
        offsets.push(total_size);
        total_size += self.f52.as_slice().len();
        offsets.push(total_size);
        total_size += self.f53.as_slice().len();
        offsets.push(total_size);
        total_size += self.f54.as_slice().len();
        offsets.push(total_size);
        total_size += self.f55.as_slice().len();
        offsets.push(total_size);
        total_size += self.f56.as_slice().len();
        offsets.push(total_size);
        total_size += self.f57.as_slice().len();
        offsets.push(total_size);
        total_size += self.f58.as_slice().len();
        offsets.push(total_size);
        total_size += self.f59.as_slice().len();
        offsets.push(total_size);
        total_size += self.f60.as_slice().len();
        offsets.push(total_size);
        total_size += self.f61.as_slice().len();
        offsets.push(total_size);
        total_size += self.f62.as_slice().len();
        offsets.push(total_size);
        total_size += self.f63.as_slice().len();
        offsets.push(total_size);
        total_size += self.f64.as_slice().len();
        offsets.push(total_size);
        total_size += self.f65.as_slice().len();
        offsets.push(total_size);
        total_size += self.f66.as_slice().len();
        offsets.push(total_size);
        total_size += self.f67.as_slice().len();
        offsets.push(total_size);
        total_size += self.f68.as_slice().len();
        offsets.push(total_size);
        total_size += self.f69.as_slice().len();
        offsets.push(total_size);
        total_size += self.f70.as_slice().len();
        offsets.push(total_size);
        total_size += self.f71.as_slice().len();
        offsets.push(total_size);
        total_size += self.f72.as_slice().len();
        offsets.push(total_size);
        total_size += self.f73.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.f0.as_slice())?;
        writer.write_all(self.f1.as_slice())?;
        writer.write_all(self.f2.as_slice())?;
        writer.write_all(self.f3.as_slice())?;
        writer.write_all(self.f4.as_slice())?;
        writer.write_all(self.f5.as_slice())?;
        writer.write_all(self.f6.as_slice())?;
        writer.write_all(self.f7.as_slice())?;
        writer.write_all(self.f8.as_slice())?;
        writer.write_all(self.f9.as_slice())?;
        writer.write_all(self.f10.as_slice())?;
        writer.write_all(self.f11.as_slice())?;
        writer.write_all(self.f12.as_slice())?;
        writer.write_all(self.f13.as_slice())?;
        writer.write_all(self.f14.as_slice())?;
        writer.write_all(self.f15.as_slice())?;
        writer.write_all(self.f16.as_slice())?;
        writer.write_all(self.f17.as_slice())?;
        writer.write_all(self.f18.as_slice())?;
        writer.write_all(self.f19.as_slice())?;
        writer.write_all(self.f20.as_slice())?;
        writer.write_all(self.f21.as_slice())?;
        writer.write_all(self.f22.as_slice())?;
        writer.write_all(self.f23.as_slice())?;
        writer.write_all(self.f24.as_slice())?;
        writer.write_all(self.f25.as_slice())?;
        writer.write_all(self.f26.as_slice())?;
        writer.write_all(self.f27.as_slice())?;
        writer.write_all(self.f28.as_slice())?;
        writer.write_all(self.f29.as_slice())?;
        writer.write_all(self.f30.as_slice())?;
        writer.write_all(self.f31.as_slice())?;
        writer.write_all(self.f32.as_slice())?;
        writer.write_all(self.f33.as_slice())?;
        writer.write_all(self.f34.as_slice())?;
        writer.write_all(self.f35.as_slice())?;
        writer.write_all(self.f36.as_slice())?;
        writer.write_all(self.f37.as_slice())?;
        writer.write_all(self.f38.as_slice())?;
        writer.write_all(self.f39.as_slice())?;
        writer.write_all(self.f40.as_slice())?;
        writer.write_all(self.f41.as_slice())?;
        writer.write_all(self.f42.as_slice())?;
        writer.write_all(self.f43.as_slice())?;
        writer.write_all(self.f44.as_slice())?;
        writer.write_all(self.f45.as_slice())?;
        writer.write_all(self.f46.as_slice())?;
        writer.write_all(self.f47.as_slice())?;
        writer.write_all(self.f48.as_slice())?;
        writer.write_all(self.f49.as_slice())?;
        writer.write_all(self.f50.as_slice())?;
        writer.write_all(self.f51.as_slice())?;
        writer.write_all(self.f52.as_slice())?;
        writer.write_all(self.f53.as_slice())?;
        writer.write_all(self.f54.as_slice())?;
        writer.write_all(self.f55.as_slice())?;
        writer.write_all(self.f56.as_slice())?;
        writer.write_all(self.f57.as_slice())?;
        writer.write_all(self.f58.as_slice())?;
        writer.write_all(self.f59.as_slice())?;
        writer.write_all(self.f60.as_slice())?;
        writer.write_all(self.f61.as_slice())?;
        writer.write_all(self.f62.as_slice())?;
        writer.write_all(self.f63.as_slice())?;
        writer.write_all(self.f64.as_slice())?;
        writer.write_all(self.f65.as_slice())?;
        writer.write_all(self.f66.as_slice())?;
        writer.write_all(self.f67.as_slice())?;
        writer.write_all(self.f68.as_slice())?;
        writer.write_all(self.f69.as_slice())?;
        writer.write_all(self.f70.as_slice())?;
        writer.write_all(self.f71.as_slice())?;
        writer.write_all(self.f72.as_slice())?;
        writer.write_all(self.f73.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AllInOne::new_unchecked(inner.into())
    }
}
